<html>
<head>
<style>
body { background-color:#fff; padding: 0; margin: 0; }
table { border:1px solid #ccc; width:100%; padding:1em; background-color:#eee; }
th { border-bottom:1px dashed #ccc; text-align:left; padding-top:0.5em; }
td { vertical-align: top; }
tr td:first-of-type { width:4em; white-space:nowrap; }
.arg { color:#c00; }
.type { color:#00f; }
.meta, th { color:#aaa; }
.page { clear: both; }
.page, .menu, .cont { box-sizing:border-box; display:block; margin: 0; }
.menu, .cont { overflow-x:hidden; overflow-y:auto; height: 100%; max-height: 100%; padding: 1em; }
.menu { float:left; width:25%; background-color:#eee; border-right:1px solid #ccc; }
.cont { float:right; width:75%; }
.see { font-size: 0.9em; padding: 0.5em; }
h1,h2,h3 { padding: 1em 0 0 0; margin: 0; }
ul { padding: 0.5 1em; margin: 0; }
hr { border-top: 1px solid #ccc; }
</style>
</head>
<body>
<div class='page'>
<div class='cont'>
<h1>Steamworks for Lua/FFI</h1>
This is a cross-platform LuaJIT/FFI wrapper for Steamworks v1.51.
The library provides easy and simple Steamworks integration,
using the original redistributable binaries provided by Valve.<br>
Website:
<a href="https://2dengine.com/?p=sworks">https://2dengine.com/?p=sworks</a><br>
Repository:
<a href="https://github.com/2dengine/sworks-ffi">https://github.com/2dengine/sworks-ffi</a><br>

<h2 id='steam'>steam</h2>
This is the main module used to interact with Steamworks.<br>
<table>
<tr><td><a href='#steam.activateOverlay'>steam.activateOverlay</a>(<span class='arg'>page</span>, <span class='arg'>user</span>)</td><td>Opens the Steam overlay if available to a specific dialog or page.</td></tr>
<tr><td><a href='#steam.getAchievements'>steam.getAchievements</a>()</td><td>Retrives all available achievements for the current game.</td></tr>
<tr><td><a href='#steam.getAppId'>steam.getAppId</a>()</td><td>Gets the current game's AppID.</td></tr>
<tr><td><a href='#steam.getBoard'>steam.getBoard</a>(<span class='arg'>name</span>, <span class='arg'>func</span>)</td><td>Requests an existing leaderboard based on name.  This is an asynchronous request so the returned <a href='#Board'>Board</a> object cannot be used right away.  Please provide a callback function or wait for <a href='#Board:onFind'>Board:onFind</a> before making additional requests.</td></tr>
<tr><td><a href='#steam.getClan'>steam.getClan</a>(<span class='arg'>id</span>)</td><td>Finds a specific clan based on ID.</td></tr>
<tr><td><a href='#steam.getClans'>steam.getClans</a>()</td><td>Retrieves clans which the owner has previously joined.</td></tr>
<tr><td><a href='#steam.getCountry'>steam.getCountry</a>()</td><td>Gets the owner's geographic location based on IP.</td></tr>
<tr><td><a href='#steam.getFriends'>steam.getFriends</a>()</td><td>Retrieves the owner's friends.</td></tr>
<tr><td><a href='#steam.getLanguage'>steam.getLanguage</a>()</td><td>Gets the selected language code for the current game or the client.</td></tr>
<tr><td><a href='#steam.getLobby'>steam.getLobby</a>(<span class='arg'>id</span>)</td><td>Retrieves an existing lobby based on ID.</td></tr>
<tr><td><a href='#steam.getPlayedWith'>steam.getPlayedWith</a>()</td><td>Retrieves other users the owner has recently played with.</td></tr>
<tr><td><a href='#steam.getSocket'>steam.getSocket</a>(<span class='arg'>channel</span>, <span class='arg'>kind</span>)</td><td>Creates or requests an existing socket via its channel number.</td></tr>
<tr><td><a href='#steam.getSubscribedUGC'>steam.getSubscribedUGC</a>(<span class='arg'>offset1</span>, <span class='arg'>offset2</span>)</td><td>Retrives all subscribed user-generated items.</td></tr>
<tr><td><a href='#steam.getUGC'>steam.getUGC</a>(<span class='arg'>id</span>, <span class='arg'>appid</span>)</td><td>Finds an existing user-generated content item based on ID.</td></tr>
<tr><td><a href='#steam.getUser'>steam.getUser</a>(<span class='arg'>id</span>)</td><td>Finds a specific user based on ID.  Returns the owner if no id is specified.</td></tr>
<tr><td><a href='#steam.init'>steam.init</a>()</td><td>Initializes the Steam client interface.  This function will fail if the Steam client is not running or you don't have a valid AppID.  Your AppID must be saved as "steam_appid.txt" and placed in your base directory.  You will also need to include the correct version of the Steamworks binaries provided by Valve.</td></tr>
<tr><td><a href='#steam.isBigPicture'>steam.isBigPicture</a>()</td><td>Checks if the client is running in "Big Picture" mode.</td></tr>
<tr><td><a href='#steam.isConnected'>steam.isConnected</a>()</td><td>Checks if the owner is connected to Steam.</td></tr>
<tr><td><a href='#steam.isRunning'>steam.isRunning</a>()</td><td>Checks if your Steam client is initialized and running.</td></tr>
<tr><td><a href='#steam.newBoard'>steam.newBoard</a>(<span class='arg'>name</span>, <span class='arg'>sort</span>, <span class='arg'>display</span>, <span class='arg'>func</span>)</td><td>Creates or requests an existing leaderboard based on name.  This is an asynchronous request so the returned <a href='#Board'>Board</a> object cannot be used right away.  Please provide a callback function or wait for <a href='#Board:onCreate'>Board:onCreate</a> before making additional requests.</td></tr>
<tr><td><a href='#steam.newLobby'>steam.newLobby</a>(<span class='arg'>kind</span>, <span class='arg'>limit</span>, <span class='arg'>func</span>)</td><td>Creates a new lobby.  This is an asynchronous request so the returned <a href='#Lobby'>Lobby</a> object cannot be used right away.  Please provide a callback function or wait for <a href='#Lobby:onCreate'>Lobby:onCreate</a> before making additional requests.</td></tr>
<tr><td><a href='#steam.newUGC'>steam.newUGC</a>(<span class='arg'>kind</span>, <span class='arg'>appid</span>, <span class='arg'>func</span>)</td><td>Creates a new user-generated content item.  This is an asynchronous request so the returned <a href='#UGC'>UGC</a> object cannot be used right away.  Please provide a callback function or wait for <a href='#UGC:onCreate'>UGC:onCreate</a> before making additional requests.</td></tr>
<tr><td><a href='#steam.queryLobbies'>steam.queryLobbies</a>(<span class='arg'>what</span>, <span class='arg'>limit</span>, <span class='arg'>func</span>)</td><td>Searches for existing lobbies for the current game.  This is an asynchronous request so please provide a callback function to receive the results.</td></tr>
<tr><td><a href='#steam.queryUGC'>steam.queryUGC</a>(<span class='arg'>what</span>, <span class='arg'>offset1</span>, <span class='arg'>offset2</span>, <span class='arg'>func</span>, <span class='arg'>list</span>)</td><td>Searches for user-generated content by a specific user or by filter.  This is an asynchronous request so please provide a callback function to receive the results.</td></tr>
<tr><td><a href='#steam.request'>steam.request</a>(<span class='arg'>url</span>, <span class='arg'>post</span>, <span class='arg'>func</span>)</td><td>Makes a new HTTP or HTTPS request.  This is an asynchronous request so please provide a callback function to receive the results.</td></tr>
<tr><td><a href='#steam.restart'>steam.restart</a>(<span class='arg'>appid</span>)</td><td>Checks if your executable was launched through Steam.  Returns true and re-launches your game through Steam if it was not.  Returns false when "steam_appid.txt" is present.</td></tr>
<tr><td><a href='#steam.setNotificationPosition'>steam.setNotificationPosition</a>(<span class='arg'>string</span>, <span class='arg'>number</span>, <span class='arg'>number</span>)</td><td>Sets the position and offset of the notification pop-up.</td></tr>
<tr><td><a href='#steam.shutdown'>steam.shutdown</a>()</td><td>Shuts down the Steam client interface.</td></tr>
<tr><td><a href='#steam.update'>steam.update</a>()</td><td>This function triggers any asynchronous callbacks.  You must call steam.update regularly to ensure that your requests are processed.</td></tr>
</table>
<h3 id='steam.activateOverlay'>steam.activateOverlay(<span class='arg'>page</span>, <span class='arg'>user</span>)</h3>
Opens the Steam overlay if available to a specific dialog or page.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>page</b> ("friends")<br>
Dialog, AppID or URL address. Possible dialog values: "friends", "community", "players", "settings", "officialgamegroup", "stats" or "achievements"</td></tr>
<tr><td><a href='#User' class='type'>User</a></td><td><b class='arg'>user</b> (optional)<br>
User object</td></tr>
</table>
<div class='see'>See: <a href='#steam.setNotificationPosition'>steam.setNotificationPosition</a>, <a href='#User:activateOverlay'>User:activateOverlay</a></div>
<h3 id='steam.getAchievements'>steam.getAchievements()</h3>
Retrives all available achievements for the current game.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>table</a></td>
<td>Table of achievement names</td></tr>
</table>
<div class='see'>See: <a href='#User:getAchievement'>User:getAchievement</a></div>
<h3 id='steam.getAppId'>steam.getAppId()</h3>
Gets the current game's AppID.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>AppID of the current game</td></tr>
</table>
<h3 id='steam.getBoard'>steam.getBoard(<span class='arg'>name</span>, <span class='arg'>func</span>)</h3>
Requests an existing leaderboard based on name.  This is an asynchronous request so the returned <a href='#Board'>Board</a> object cannot be used right away.  Please provide a callback function or wait for <a href='#Board:onFind'>Board:onFind</a> before making additional requests.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>name</b><br>
Name of an existing leaderboard</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the board is found</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#Board' class='type'>Board</a></td>
<td>Board object</td></tr>
</table>
<div class='see'>See: <a href='#Board:onFind'>Board:onFind</a>, <a href='#steam.newBoard'>steam.newBoard</a></div>
<h3 id='steam.getClan'>steam.getClan(<span class='arg'>id</span>)</h3>
Finds a specific clan based on ID.
<table>
<tr><td><a class='type'>value</a></td><td><b class='arg'>id</b><br>
Clan ID</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#Clan' class='type'>Clan</a></td>
<td>Clan object</td></tr>
</table>
<div class='see'>See: <a href='#steam.getClans'>steam.getClans</a></div>
<h3 id='steam.getClans'>steam.getClans()</h3>
Retrieves clans which the owner has previously joined.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>table</a></td>
<td>Table of <a href='#Clan'>Clan</a> objects</td></tr>
</table>
<div class='see'>See: <a href='#steam.getClan'>steam.getClan</a></div>
<h3 id='steam.getCountry'>steam.getCountry()</h3>
Gets the owner's geographic location based on IP.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Country code</td></tr>
</table>
<div class='see'>See: <a href='#steam.getLanguage'>steam.getLanguage</a></div>
<h3 id='steam.getFriends'>steam.getFriends()</h3>
Retrieves the owner's friends.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>table</a></td>
<td>Table of <a href='#User'>User</a> objects</td></tr>
</table>
<div class='see'>See: <a href='#User:isFriend'>User:isFriend</a></div>
<h3 id='steam.getLanguage'>steam.getLanguage()</h3>
Gets the selected language code for the current game or the client.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Language code</td></tr>
</table>
<div class='see'>See: <a href='#steam.getCountry'>steam.getCountry</a></div>
<h3 id='steam.getLobby'>steam.getLobby(<span class='arg'>id</span>)</h3>
Retrieves an existing lobby based on ID.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>id</b><br>
ID of an existing lobby</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#Lobby' class='type'>Lobby</a></td>
<td>Lobby object</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:join'>Lobby:join</a>, <a href='#steam.newLobby'>steam.newLobby</a>, <a href='#steam.queryLobbies'>steam.queryLobbies</a></div>
<h3 id='steam.getPlayedWith'>steam.getPlayedWith()</h3>
Retrieves other users the owner has recently played with.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>table</a></td>
<td>Table of <a href='#User'>User</a> objects</td></tr>
</table>
<div class='see'>See: <a href='#User:getPlayedWith'>User:getPlayedWith</a></div>
<h3 id='steam.getSocket'>steam.getSocket(<span class='arg'>channel</span>, <span class='arg'>kind</span>)</h3>
Creates or requests an existing socket via its channel number.
<table>
<tr><td><a class='type'>number</a></td><td><b class='arg'>channel</b> (0)<br>
Channel number</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>kind</b> ("unreliable")<br>
Kind of socket: "unreliable", "nodelay", "reliable" or "buffered"</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#Socket' class='type'>Socket</a></td>
<td>Socket object</td></tr>
</table>
<h3 id='steam.getSubscribedUGC'>steam.getSubscribedUGC(<span class='arg'>offset1</span>, <span class='arg'>offset2</span>)</h3>
Retrives all subscribed user-generated items.
<table>
<tr><td><a class='type'>number</a></td><td><b class='arg'>offset1</b><br>
Starting offset used for pagination</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>offset2</b><br>
Ending offset used for pagination</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>table</a></td>
<td>Table of <a href='#UGC'>UGC</a> objects</td></tr>
</table>
<div class='see'>See: <a href='#UGC:subscribe'>UGC:subscribe</a>, <a href='#steam.getUGC'>steam.getUGC</a>, <a href='#steam.queryUGC'>steam.queryUGC</a></div>
<h3 id='steam.getUGC'>steam.getUGC(<span class='arg'>id</span>, <span class='arg'>appid</span>)</h3>
Finds an existing user-generated content item based on ID.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>id</b><br>
ID of an existing user-generated item </td></tr>
<tr><td><a class='type'>value</a></td><td><b class='arg'>appid</b> (optional)<br>
AppID if different from the base game</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#UGC' class='type'>UGC</a></td>
<td>User-generated item</td></tr>
</table>
<div class='see'>See: <a href='#steam.newUGC'>steam.newUGC</a>, <a href='#steam.queryUGC'>steam.queryUGC</a>, <a href='#steam.getSubscribedUGC'>steam.getSubscribedUGC</a></div>
<h3 id='steam.getUser'>steam.getUser(<span class='arg'>id</span>)</h3>
Finds a specific user based on ID.  Returns the owner if no id is specified.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>id</b> (optional)<br>
User ID in decimal format</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#User' class='type'>User</a></td>
<td>User object</td></tr>
</table>
<h3 id='steam.init'>steam.init()</h3>
Initializes the Steam client interface.  This function will fail if the Steam client is not running or you don't have a valid AppID.  Your AppID must be saved as "steam_appid.txt" and placed in your base directory.  You will also need to include the correct version of the Steamworks binaries provided by Valve.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the interface is initialized</td></tr>
</table>
<div class='see'>See: <a href='#steam.shutdown'>steam.shutdown</a>, <a href='#steam.restart'>steam.restart</a>, <a href='#steam.update'>steam.update</a>, <a href='#steam.isRunning'>steam.isRunning</a></div>
<h3 id='steam.isBigPicture'>steam.isBigPicture()</h3>
Checks if the client is running in "Big Picture" mode.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if "Big Picture" mode is enabled</td></tr>
</table>
<h3 id='steam.isConnected'>steam.isConnected()</h3>
Checks if the owner is connected to Steam.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if connected or false when offline</td></tr>
</table>
<h3 id='steam.isRunning'>steam.isRunning()</h3>
Checks if your Steam client is initialized and running.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if already running</td></tr>
</table>
<div class='see'>See: <a href='#steam.init'>steam.init</a>, <a href='#steam.shutdown'>steam.shutdown</a></div>
<h3 id='steam.newBoard'>steam.newBoard(<span class='arg'>name</span>, <span class='arg'>sort</span>, <span class='arg'>display</span>, <span class='arg'>func</span>)</h3>
Creates or requests an existing leaderboard based on name.  This is an asynchronous request so the returned <a href='#Board'>Board</a> object cannot be used right away.  Please provide a callback function or wait for <a href='#Board:onCreate'>Board:onCreate</a> before making additional requests.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>name</b><br>
Leaderboard name</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>sort</b> ("desc")<br>
Sorting method: "asc" or "desc"</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>display</b> ("numeric")<br>
Display style: "none", "numeric", "seconds" or "milliseconds"</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the board is created</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#Board' class='type'>Board</a></td>
<td>Board object</td></tr>
</table>
<div class='see'>See: <a href='#Board:onCreate'>Board:onCreate</a>, <a href='#steam.getBoard'>steam.getBoard</a></div>
<h3 id='steam.newLobby'>steam.newLobby(<span class='arg'>kind</span>, <span class='arg'>limit</span>, <span class='arg'>func</span>)</h3>
Creates a new lobby.  This is an asynchronous request so the returned <a href='#Lobby'>Lobby</a> object cannot be used right away.  Please provide a callback function or wait for <a href='#Lobby:onCreate'>Lobby:onCreate</a> before making additional requests.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>kind</b> (public)<br>
Kind of lobby: "private", "friends", "public" or "invisible"</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>limit</b> (250)<br>
Maximum number of users allowed to join the lobby.</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the lobby is created</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:onCreate'>Lobby:onCreate</a>, <a href='#steam.getLobby'>steam.getLobby</a></div>
<h3 id='steam.newUGC'>steam.newUGC(<span class='arg'>kind</span>, <span class='arg'>appid</span>, <span class='arg'>func</span>)</h3>
Creates a new user-generated content item.  This is an asynchronous request so the returned <a href='#UGC'>UGC</a> object cannot be used right away.  Please provide a callback function or wait for <a href='#UGC:onCreate'>UGC:onCreate</a> before making additional requests.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>kind</b> ("community")<br>
Type of object: "community", "micro", "collection", "art", "video", "screenshot", "game", "software", "concept", "webguide", "guide", "merch", "binding", "accessinvite", "steamvideo" or "managed".</td></tr>
<tr><td><a class='type'>value</a></td><td><b class='arg'>appid</b> (optional)<br>
AppID if different from the base game</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the item is created</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#UGC' class='type'>UGC</a></td>
<td>User-generated item</td></tr>
</table>
<div class='see'>See: <a href='#UGC:onCreate'>UGC:onCreate</a>, <a href='#steam.getUGC'>steam.getUGC</a></div>
<h3 id='steam.queryLobbies'>steam.queryLobbies(<span class='arg'>what</span>, <span class='arg'>limit</span>, <span class='arg'>func</span>)</h3>
Searches for existing lobbies for the current game.  This is an asynchronous request so please provide a callback function to receive the results.
<table>
<tr><td><a class='type'>table</a></td><td><b class='arg'>what</b> (optional)<br>
Table with numerical or string filters</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>limit</b> (optional)<br>
Maximum number of results</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b><br>
Callback function triggered when the search results are ready</td></tr>
</table>
<div class='see'>See: <a href='#steam.getLobby'>steam.getLobby</a></div>
<h3 id='steam.queryUGC'>steam.queryUGC(<span class='arg'>what</span>, <span class='arg'>offset1</span>, <span class='arg'>offset2</span>, <span class='arg'>func</span>, <span class='arg'>list</span>)</h3>
Searches for user-generated content by a specific user or by filter.  This is an asynchronous request so please provide a callback function to receive the results.
<table>
<tr><td><a class='type'>value</a></td><td><b class='arg'>what</b><br>
User object or filter: "popular", "recent", "friends" or "unrated"</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>offset1</b><br>
Starting offset used for pagination</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>offset2</b><br>
Ending offset used for pagination</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b><br>
Callback function triggered when the search results are ready</td></tr>
<tr><td><a class='type'>table</a></td><td><b class='arg'>list</b> (optional)<br>
Table of <a href='#UGC'>UGC</a> objects</td></tr>
</table>
<div class='see'>See: <a href='#steam.getUGC'>steam.getUGC</a>, <a href='#steam.getSubscribedUGC'>steam.getSubscribedUGC</a></div>
<h3 id='steam.request'>steam.request(<span class='arg'>url</span>, <span class='arg'>post</span>, <span class='arg'>func</span>)</h3>
Makes a new HTTP or HTTPS request.  This is an asynchronous request so please provide a callback function to receive the results.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>url</b><br>
URL address</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>post</b> (optional)<br>
Raw post body</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b><br>
Callback function triggered once the request if completed</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the request parameters are valid</td></tr>
</table>
<div class='see'>See: <a href='#steam.isConnected'>steam.isConnected</a></div>
<h3 id='steam.restart'>steam.restart(<span class='arg'>appid</span>)</h3>
Checks if your executable was launched through Steam.  Returns true and re-launches your game through Steam if it was not.  Returns false when "steam_appid.txt" is present.
<table>
<tr><td><a class='type'>value</a></td><td><b class='arg'>appid</b> (optional)<br>
AppID</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if restarting the game is necessary</td></tr>
</table>
<div class='see'>See: <a href='#steam.shutdown'>steam.shutdown</a></div>
<h3 id='steam.setNotificationPosition'>steam.setNotificationPosition(<span class='arg'>string</span>, <span class='arg'>number</span>, <span class='arg'>number</span>)</h3>
Sets the position and offset of the notification pop-up.
<table>
<tr><td><a class='type'>value</a></td><td><b class='arg'>string</b><br>
pos Target corner: "topleft", "topright", "bottomleft" or "bottomright"</td></tr>
<tr><td><a class='type'>value</a></td><td><b class='arg'>number</b> (optional)<br>
ox Inset from the corner</td></tr>
<tr><td><a class='type'>value</a></td><td><b class='arg'>number</b> (optional)<br>
oy Inset from the corner</td></tr>
</table>
<div class='see'>See: <a href='#steam.activateOverlay'>steam.activateOverlay</a></div>
<h3 id='steam.shutdown'>steam.shutdown()</h3>
Shuts down the Steam client interface.
<div class='see'>See: <a href='#steam.init'>steam.init</a>, <a href='#steam.restart'>steam.restart</a></div>
<h3 id='steam.update'>steam.update()</h3>
This function triggers any asynchronous callbacks.  You must call steam.update regularly to ensure that your requests are processed.
<div class='see'>See: <a href='#steam.init'>steam.init</a>, <a href='#steam.isRunning'>steam.isRunning</a></div>
<br><br><br><h2 id='Handle'>Handle</h2>
Base class for all Steamworks objects.<br>
<table>
<tr><td><a href='#Handle:callback'>Handle:callback</a>(<span class='arg'>func</span>, <span class='arg'>result</span>, <span class='arg'>...</span>)</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:destroy'>Handle:destroy</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:getId'>Handle:getId</a>()</td><td>Returns the unique Steam ID as a string.</td></tr>
<tr><td><a href='#Handle:new'>Handle:new</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:onError'>Handle:onError</a>(<span class='arg'>message</span>)</td><td>This callback is triggered when any requests fails.</td></tr>
<tr><td><a href='#Handle:setId'>Handle:setId</a>(<span class='arg'>handle</span>)</td><td>This is an internal function.</td></tr>
</table>
<h3 id='Handle:callback'>Handle:callback(<span class='arg'>func</span>, <span class='arg'>result</span>, <span class='arg'>...</span>)</h3>
This is an internal function.
<table>
<tr><td><a class='type'>value</a></td><td><b class='arg'>func</b><br>
Name or function</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>result</b><br>
Result status</td></tr>
<tr><td><a class='type'>value</a></td><td><b class='arg'>...</b><br>
Variable arguments</td></tr>
</table>
<div class='see'>See: <a href='#Handle.onError'>Handle.onError</a></div>
<h3 id='Handle:destroy'>Handle:destroy()</h3>
This is an internal function.
<h3 id='Handle:getId'>Handle:getId()</h3>
Returns the unique Steam ID as a string.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Steam ID</td></tr>
</table>
<h3 id='Handle:new'>Handle:new()</h3>
This is an internal function.
<h3 id='Handle:onError'>Handle:onError(<span class='arg'>message</span>)</h3>
This callback is triggered when any requests fails.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>message</b><br>
Error message</td></tr>
</table>
<h3 id='Handle:setId'>Handle:setId(<span class='arg'>handle</span>)</h3>
This is an internal function.
<table>
<tr><td><a class='type'>value</a></td><td><b class='arg'>handle</b><br>
Steam ID</td></tr>
</table>
<br><br><br><h2 id='Board'>Board</h2>
Steam supports persistent leaderboards with automatically ordered entries.
 These leaderboards can be used to display global and friend leaderboards in your game and on your community webpage.
 Each Steamworks title can create up to 10,000 leaderboards, and each leaderboard can be retrieved immediately after a player's score has been inserted.
 For each leaderboard, a player can have one entry.
 There is no limit on the number of players per leaderboard.<br>
<table>
<tr><th colspan=2>Handle</th></tr>
<tr><td><a href='#Handle:callback'>Handle:callback</a>(<span class='arg'>func</span>, <span class='arg'>result</span>, <span class='arg'>...</span>)</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:getId'>Handle:getId</a>()</td><td>Returns the unique Steam ID as a string.</td></tr>
<tr><td><a href='#Handle:new'>Handle:new</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:onError'>Handle:onError</a>(<span class='arg'>message</span>)</td><td>This callback is triggered when any requests fails.</td></tr>
<tr><td><a href='#Handle:setId'>Handle:setId</a>(<span class='arg'>handle</span>)</td><td>This is an internal function.</td></tr>
<tr><th colspan=2>Board</th></tr>
<tr><td><a href='#Board:attach'>Board:attach</a>(<span class='arg'>ugc</span>, <span class='arg'>func</span>)</td><td>Attaches an existing user-generated item (such as a replay) to the owner's leaderboard entry.  This is an asynchronous request that triggers the <a href='#Board:onAttach'>Board:onAttach</a> callback.</td></tr>
<tr><td><a href='#Board:create'>Board:create</a>(<span class='arg'>name</span>, <span class='arg'>sort</span>, <span class='arg'>display</span>, <span class='arg'>func</span>)</td><td>This is an internal function.  Please use <a href='#steam.newBoard'>steam.newBoard</a> instead.</td></tr>
<tr><td><a href='#Board:destroy'>Board:destroy</a>()</td><td>Invalidates the board so that any subsequent requests will fail.</td></tr>
<tr><td><a href='#Board:download'>Board:download</a>(<span class='arg'>what</span>, <span class='arg'>index1</span>, <span class='arg'>index2</span>, <span class='arg'>func</span>)</td><td>Downloads entries from the loaderboard based on a filter or for a specific user.  This is an asynchronous request that triggers the <a href='#Board:onDownload'>Board:onDownload</a> callback.</td></tr>
<tr><td><a href='#Board:getEntryCount'>Board:getEntryCount</a>()</td><td>Returns the total number of entries in the leaderboard.</td></tr>
<tr><td><a href='#Board:getName'>Board:getName</a>()</td><td>Returns the name of the board.</td></tr>
<tr><td><a href='#Board:init'>Board:init</a>(<span class='arg'>name</span>, <span class='arg'>func</span>)</td><td>This is an internal function.  Please use <a href='#steam.getBoard'>steam.getBoard</a> instead.</td></tr>
<tr><td><a href='#Board:onAttach'>Board:onAttach</a>(<span class='arg'>ugc</span>)</td><td>Callback triggered after a user-generated item is attached to the leaderboard.</td></tr>
<tr><td><a href='#Board:onCreate'>Board:onCreate</a>()</td><td>Callback triggered after the new leaderboard is created.</td></tr>
<tr><td><a href='#Board:onDownload'>Board:onDownload</a>(<span class='arg'>entries</span>, <span class='arg'>count</span>)</td><td>Callback triggered after entries are downloaded from the leaderboard.</td></tr>
<tr><td><a href='#Board:onFind'>Board:onFind</a>()</td><td>Callback triggered after the requested leaderboard is found.</td></tr>
<tr><td><a href='#Board:onUpload'>Board:onUpload</a>(<span class='arg'>changed</span>)</td><td>Callback triggered after a score is uploaded to the leaderboard.</td></tr>
<tr><td><a href='#Board:upload'>Board:upload</a>(<span class='arg'>score</span>, <span class='arg'>method</span>, <span class='arg'>func</span>)</td><td>Uploads a new entry on the leaderboard.  Uploading scores to Steam is rate limited to 10 uploads per 10 minutes  and you may only have one outstanding call to this function at a time.  This is an asynchronous request that triggers the <a href='#Board:onUpload'>Board:onUpload</a> callback.</td></tr>
</table>
<h3 id='Board:attach'>Board:attach(<span class='arg'>ugc</span>, <span class='arg'>func</span>)</h3>
Attaches an existing user-generated item (such as a replay) to the owner's leaderboard entry.  This is an asynchronous request that triggers the <a href='#Board:onAttach'>Board:onAttach</a> callback.
<table>
<tr><td><a href='#UGC' class='type'>UGC</a></td><td><b class='arg'>ugc</b><br>
User-generated item</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b><br>
Callback function triggered when the UGC is attached</td></tr>
</table>
<div class='see'>See: <a href='#Board:onAttach'>Board:onAttach</a></div>
<h3 id='Board:create'>Board:create(<span class='arg'>name</span>, <span class='arg'>sort</span>, <span class='arg'>display</span>, <span class='arg'>func</span>)</h3>
This is an internal function.  Please use <a href='#steam.newBoard'>steam.newBoard</a> instead.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>name</b><br>
Leaderboard name</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>sort</b> ("desc")<br>
Sorting method: "asc" or "desc"</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>display</b> ("numeric")<br>
Display style: "none", "numeric", "seconds" or "milliseconds"</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the board is created</td></tr>
</table>
<div class='see'>See: <a href='#steam.newBoard'>steam.newBoard</a></div>
<h3 id='Board:destroy'>Board:destroy()</h3>
Invalidates the board so that any subsequent requests will fail.
<h3 id='Board:download'>Board:download(<span class='arg'>what</span>, <span class='arg'>index1</span>, <span class='arg'>index2</span>, <span class='arg'>func</span>)</h3>
Downloads entries from the loaderboard based on a filter or for a specific user.  This is an asynchronous request that triggers the <a href='#Board:onDownload'>Board:onDownload</a> callback.
<table>
<tr><td><a class='type'>value</a></td><td><b class='arg'>what</b> ("global")<br>
User object or filter: "global", "user" or "friends"</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>index1</b> (1)<br>
Starting offset used for pagination</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>index2</b> (optional)<br>
Ending offset used for pagination</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the entries are downloaded</td></tr>
</table>
<div class='see'>See: <a href='#Board:onDownload'>Board:onDownload</a></div>
<h3 id='Board:getEntryCount'>Board:getEntryCount()</h3>
Returns the total number of entries in the leaderboard.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>Number of entries</td></tr>
</table>
<h3 id='Board:getName'>Board:getName()</h3>
Returns the name of the board.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Board name</td></tr>
</table>
<h3 id='Board:init'>Board:init(<span class='arg'>name</span>, <span class='arg'>func</span>)</h3>
This is an internal function.  Please use <a href='#steam.getBoard'>steam.getBoard</a> instead.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>name</b><br>
Name of an existing leaderboard</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the board is found</td></tr>
</table>
<div class='see'>See: <a href='#steam.getBoard'>steam.getBoard</a></div>
<h3 id='Board:onAttach'>Board:onAttach(<span class='arg'>ugc</span>)</h3>
Callback triggered after a user-generated item is attached to the leaderboard.
<table>
<tr><td><a href='#UGC' class='type'>UGC</a></td><td><b class='arg'>ugc</b><br>
User-generated item</td></tr>
</table>
<div class='see'>See: <a href='#steam.newUGC'>steam.newUGC</a></div>
<h3 id='Board:onCreate'>Board:onCreate()</h3>
Callback triggered after the new leaderboard is created.
<div class='see'>See: <a href='#steam.newBoard'>steam.newBoard</a></div>
<h3 id='Board:onDownload'>Board:onDownload(<span class='arg'>entries</span>, <span class='arg'>count</span>)</h3>
Callback triggered after entries are downloaded from the leaderboard.
<table>
<tr><td><a class='type'>table</a></td><td><b class='arg'>entries</b><br>
Table of leaderboard entries</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>count</b><br>
Total number of entries</td></tr>
</table>
<div class='see'>See: <a href='#Board:download'>Board:download</a></div>
<h3 id='Board:onFind'>Board:onFind()</h3>
Callback triggered after the requested leaderboard is found.
<div class='see'>See: <a href='#steam.getBoard'>steam.getBoard</a></div>
<h3 id='Board:onUpload'>Board:onUpload(<span class='arg'>changed</span>)</h3>
Callback triggered after a score is uploaded to the leaderboard.
<table>
<tr><td><a class='type'>boolean</a></td><td><b class='arg'>changed</b><br>
True if the the leaderboard has changed</td></tr>
</table>
<div class='see'>See: <a href='#Board:upload'>Board:upload</a></div>
<h3 id='Board:upload'>Board:upload(<span class='arg'>score</span>, <span class='arg'>method</span>, <span class='arg'>func</span>)</h3>
Uploads a new entry on the leaderboard.  Uploading scores to Steam is rate limited to 10 uploads per 10 minutes  and you may only have one outstanding call to this function at a time.  This is an asynchronous request that triggers the <a href='#Board:onUpload'>Board:onUpload</a> callback.
<table>
<tr><td><a class='type'>number</a></td><td><b class='arg'>score</b><br>
Score to upload</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>method</b> ("best")<br>
The upload method determines if we want to keep the best scores or the latest. Possible values: "none", "best" or "latest"</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the entry is uploaded</td></tr>
</table>
<div class='see'>See: <a href='#Board:onUpload'>Board:onUpload</a></div>
<br><br><br><h2 id='Clan'>Clan</h2>
Clans are basically Steam groups.<br>
<table>
<tr><th colspan=2>Handle</th></tr>
<tr><td><a href='#Handle:callback'>Handle:callback</a>(<span class='arg'>func</span>, <span class='arg'>result</span>, <span class='arg'>...</span>)</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:destroy'>Handle:destroy</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:getId'>Handle:getId</a>()</td><td>Returns the unique Steam ID as a string.</td></tr>
<tr><td><a href='#Handle:new'>Handle:new</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:onError'>Handle:onError</a>(<span class='arg'>message</span>)</td><td>This callback is triggered when any requests fails.</td></tr>
<tr><td><a href='#Handle:setId'>Handle:setId</a>(<span class='arg'>handle</span>)</td><td>This is an internal function.</td></tr>
<tr><th colspan=2>Clan</th></tr>
<tr><td><a href='#Clan:getActivity'>Clan:getActivity</a>()</td><td>Gets the most recent information we have about what the users in a Steam Group are doing.</td></tr>
<tr><td><a href='#Clan:getChatMembers'>Clan:getChatMembers</a>()</td><td>Returns a list of all of the members present in the Steam group chat.</td></tr>
<tr><td><a href='#Clan:getChatMessage'>Clan:getChatMessage</a>(<span class='arg'>index</span>)</td><td>Gets message from the Steam group chat room.  Chat messages are indexed by number.</td></tr>
<tr><td><a href='#Clan:getChatMessageCount'>Clan:getChatMessageCount</a>()</td><td>Gets the total number of messages in the Steam group chat room.</td></tr>
<tr><td><a href='#Clan:getName'>Clan:getName</a>()</td><td>Gets the display name for the specified Steam group; if the local client knows about it.</td></tr>
<tr><td><a href='#Clan:getOfficers'>Clan:getOfficers</a>()</td><td>Gets a list of the officers of the Steam group.</td></tr>
<tr><td><a href='#Clan:getOwner'>Clan:getOwner</a>()</td><td>Gets the owner of a Steam Group.</td></tr>
<tr><td><a href='#Clan:init'>Clan:init</a>(<span class='arg'>id</span>)</td><td>This is an internal function. Please use <a href='#steam.getClan'>steam.getClan</a> instead.</td></tr>
<tr><td><a href='#Clan:isOfficial'>Clan:isOfficial</a>()</td><td>Checks if the Steam group is an official game group/community hub.</td></tr>
<tr><td><a href='#Clan:isPublic'>Clan:isPublic</a>()</td><td>Checks if the Steam group is public.</td></tr>
<tr><td><a href='#Clan:joinChat'>Clan:joinChat</a>(<span class='arg'>func</span>)</td><td>Allows the user to join Steam group (clan) chats right within the game.  The behavior is somewhat complicated,  because the user may or may not be already in the group chat from outside the game or in the overlay.  You can activate the Steam client overlay to open the in-game version of the chat.  This is an asynchronous request so please use <a href='#Clan:onJoinChat'>Clan:onJoinChat</a> or provide a callback function to receive the results.</td></tr>
<tr><td><a href='#Clan:leaveChat'>Clan:leaveChat</a>()</td><td>Leaves a Steam group chat that the user has previously entered with <a href='#Clan:joinChat'>Clan:joinChat</a>.</td></tr>
<tr><td><a href='#Clan:onJoinChat'>Clan:onJoinChat</a>()</td><td>Callback triggered after joining the chat.</td></tr>
<tr><td><a href='#Clan:onReceiveActivity'>Clan:onReceiveActivity</a>()</td><td>Callback triggered when the activity stats are downloaded.</td></tr>
<tr><td><a href='#Clan:onReceiveOfficers'>Clan:onReceiveOfficers</a>()</td><td>Callback triggered when the list of officers is downloaded.</td></tr>
<tr><td><a href='#Clan:requestActivity'>Clan:requestActivity</a>(<span class='arg'>func</span>)</td><td>Refresh the Steam Group activity data or get the data from groups other than one that the current user is a member.  This is an asynchronous request so please use <a href='#Clan:onReceiveActivity'>Clan:onReceiveActivity</a> or provide a callback function to receive the results.</td></tr>
<tr><td><a href='#Clan:requestOfficers'>Clan:requestOfficers</a>(<span class='arg'>func</span>)</td><td>Requests information about Steam group officers (administrators and moderators).  You can only ask about Steam groups that a user is a member of.  This will NOT download avatars for the officers automatically.  This is an asynchronous request so please use <a href='#Clan:onReceiveOfficers'>Clan:onReceiveOfficers</a> or provide a callback function to receive the results.</td></tr>
<tr><td><a href='#Clan:sendChatMessage'>Clan:sendChatMessage</a>(<span class='arg'>msg</span>)</td><td>Sends a chat message to the Steam group chat room.</td></tr>
</table>
<h3 id='Clan:getActivity'>Clan:getActivity()</h3>
Gets the most recent information we have about what the users in a Steam Group are doing.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>Number of members that are online</td></tr>
<tr><td><a class='type'>number</a></td>
<td>Number of members that are online and in-game</td></tr>
<tr><td><a class='type'>number</a></td>
<td>Number of members in the group chat room</td></tr>
</table>
<div class='see'>See: <a href='#Clan:requestActivity'>Clan:requestActivity</a></div>
<h3 id='Clan:getChatMembers'>Clan:getChatMembers()</h3>
Returns a list of all of the members present in the Steam group chat.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>table</a></td>
<td>Table of <a href='#User'>User</a> objects</td></tr>
</table>
<h3 id='Clan:getChatMessage'>Clan:getChatMessage(<span class='arg'>index</span>)</h3>
Gets message from the Steam group chat room.  Chat messages are indexed by number.
<table>
<tr><td><a class='type'>number</a></td><td><b class='arg'>index</b><br>
Chat message index</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>String message</td></tr>
<tr><td><a href='#User' class='type'>User</a></td>
<td>Message author</td></tr>
</table>
<div class='see'>See: <a href='#Clan:getChatMessageCount'>Clan:getChatMessageCount</a></div>
<h3 id='Clan:getChatMessageCount'>Clan:getChatMessageCount()</h3>
Gets the total number of messages in the Steam group chat room.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>Number of messages</td></tr>
</table>
<div class='see'>See: <a href='#Clan:getChatMessage'>Clan:getChatMessage</a></div>
<h3 id='Clan:getName'>Clan:getName()</h3>
Gets the display name for the specified Steam group; if the local client knows about it.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Group name</td></tr>
</table>
<h3 id='Clan:getOfficers'>Clan:getOfficers()</h3>
Gets a list of the officers of the Steam group.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>table</a></td>
<td>Table of User objects</td></tr>
</table>
<div class='see'>See: <a href='#Clan:requestOfficers'>Clan:requestOfficers</a></div>
<h3 id='Clan:getOwner'>Clan:getOwner()</h3>
Gets the owner of a Steam Group.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#User' class='type'>User</a></td>
<td>The user who owns the group</td></tr>
</table>
<h3 id='Clan:init'>Clan:init(<span class='arg'>id</span>)</h3>
This is an internal function. Please use <a href='#steam.getClan'>steam.getClan</a> instead.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>id</b><br>
Clan ID</td></tr>
</table>
<div class='see'>See: <a href='#steam.getClan'>steam.getClan</a></div>
<h3 id='Clan:isOfficial'>Clan:isOfficial()</h3>
Checks if the Steam group is an official game group/community hub.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the group is official</td></tr>
</table>
<h3 id='Clan:isPublic'>Clan:isPublic()</h3>
Checks if the Steam group is public.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the group is public</td></tr>
</table>
<h3 id='Clan:joinChat'>Clan:joinChat(<span class='arg'>func</span>)</h3>
Allows the user to join Steam group (clan) chats right within the game.  The behavior is somewhat complicated,  because the user may or may not be already in the group chat from outside the game or in the overlay.  You can activate the Steam client overlay to open the in-game version of the chat.  This is an asynchronous request so please use <a href='#Clan:onJoinChat'>Clan:onJoinChat</a> or provide a callback function to receive the results.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b><br>
Callback function triggered after joining the chat</td></tr>
</table>
<div class='see'>See: <a href='#Clan:onJoinChat'>Clan:onJoinChat</a>, <a href='#Clan:leaveChat'>Clan:leaveChat</a></div>
<h3 id='Clan:leaveChat'>Clan:leaveChat()</h3>
Leaves a Steam group chat that the user has previously entered with <a href='#Clan:joinChat'>Clan:joinChat</a>.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#Clan:joinChat'>Clan:joinChat</a></div>
<h3 id='Clan:onJoinChat'>Clan:onJoinChat()</h3>
Callback triggered after joining the chat.
<div class='see'>See: <a href='#Clan:joinChat'>Clan:joinChat</a></div>
<h3 id='Clan:onReceiveActivity'>Clan:onReceiveActivity()</h3>
Callback triggered when the activity stats are downloaded.
<div class='see'>See: <a href='#Clan:requestActivity'>Clan:requestActivity</a></div>
<h3 id='Clan:onReceiveOfficers'>Clan:onReceiveOfficers()</h3>
Callback triggered when the list of officers is downloaded.
<div class='see'>See: <a href='#Clan:requestOfficers'>Clan:requestOfficers</a></div>
<h3 id='Clan:requestActivity'>Clan:requestActivity(<span class='arg'>func</span>)</h3>
Refresh the Steam Group activity data or get the data from groups other than one that the current user is a member.  This is an asynchronous request so please use <a href='#Clan:onReceiveActivity'>Clan:onReceiveActivity</a> or provide a callback function to receive the results.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b><br>
Callback function triggered when the activity stats are downloaded</td></tr>
</table>
<div class='see'>See: <a href='#Clan:onReceiveActivity'>Clan:onReceiveActivity</a>, <a href='#Clan:getActivity'>Clan:getActivity</a></div>
<h3 id='Clan:requestOfficers'>Clan:requestOfficers(<span class='arg'>func</span>)</h3>
Requests information about Steam group officers (administrators and moderators).  You can only ask about Steam groups that a user is a member of.  This will NOT download avatars for the officers automatically.  This is an asynchronous request so please use <a href='#Clan:onReceiveOfficers'>Clan:onReceiveOfficers</a> or provide a callback function to receive the results.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b><br>
Callback function triggered when the list of officers is downloaded</td></tr>
</table>
<div class='see'>See: <a href='#Clan:getOfficers'>Clan:getOfficers</a>, <a href='#Clan:onReceiveOfficers'>Clan:onReceiveOfficers</a></div>
<h3 id='Clan:sendChatMessage'>Clan:sendChatMessage(<span class='arg'>msg</span>)</h3>
Sends a chat message to the Steam group chat room.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>msg</b><br>
Message</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the message was successfully sent</td></tr>
</table>
<br><br><br><h2 id='Lobby'>Lobby</h2>
The lobby is an entity that lives on the Steam back-end servers that is a lot like a chat room.
 Users can create a new lobby; associate data with a lobby; search for lobbies based on that data; join lobbies; and share information with other users in the lobby.
 A single lobby can have up to 250 users in it, although typically most games have at most 2-16 players.
 Skill-based matchmaking is built on top of this system.<br>
<table>
<tr><th colspan=2>Handle</th></tr>
<tr><td><a href='#Handle:callback'>Handle:callback</a>(<span class='arg'>func</span>, <span class='arg'>result</span>, <span class='arg'>...</span>)</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:destroy'>Handle:destroy</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:getId'>Handle:getId</a>()</td><td>Returns the unique Steam ID as a string.</td></tr>
<tr><td><a href='#Handle:new'>Handle:new</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:onError'>Handle:onError</a>(<span class='arg'>message</span>)</td><td>This callback is triggered when any requests fails.</td></tr>
<tr><td><a href='#Handle:setId'>Handle:setId</a>(<span class='arg'>handle</span>)</td><td>This is an internal function.</td></tr>
<tr><th colspan=2>Lobby</th></tr>
<tr><td><a href='#Lobby:create'>Lobby:create</a>(<span class='arg'>kind</span>, <span class='arg'>limit</span>, <span class='arg'>func</span>)</td><td>This is an internal function.  Please use <a href='#steam.newLobby'>steam.newLobby</a> instead.</td></tr>
<tr><td><a href='#Lobby:deleteData'>Lobby:deleteData</a>(<span class='arg'>key</span>)</td><td>Removes lobby metadata.</td></tr>
<tr><td><a href='#Lobby:getChatMessage'>Lobby:getChatMessage</a>(<span class='arg'>index</span>)</td><td>Gets message from the lobby chat room.  Chat messages are indexed by number.</td></tr>
<tr><td><a href='#Lobby:getChatMessageCount'>Lobby:getChatMessageCount</a>()</td><td>Gets the total number of messages in the lobby chat room.</td></tr>
<tr><td><a href='#Lobby:getData'>Lobby:getData</a>(<span class='arg'>key</span>, <span class='arg'>user</span>)</td><td>Get lobby metadata.</td></tr>
<tr><td><a href='#Lobby:getLimit'>Lobby:getLimit</a>()</td><td>Get the current limit on the number of users who can join the lobby.</td></tr>
<tr><td><a href='#Lobby:getMembers'>Lobby:getMembers</a>()</td><td>Returns a list of members who have joined the lobby.  The current user must be in the lobby to retrieve the Steam IDs of other users in that lobby.</td></tr>
<tr><td><a href='#Lobby:getOwner'>Lobby:getOwner</a>()</td><td>Returns the lobby owner</td></tr>
<tr><td><a href='#Lobby:init'>Lobby:init</a>(<span class='arg'>id</span>)</td><td>This is an internal function.  Please use <a href='#steam.getLobby'>steam.getLobby</a> instead.</td></tr>
<tr><td><a href='#Lobby:invite'>Lobby:invite</a>(<span class='arg'>friend</span>)</td><td>Invite another user to the lobby.  Shows a list of friends if no specific user is provided.</td></tr>
<tr><td><a href='#Lobby:join'>Lobby:join</a>(<span class='arg'>func</span>)</td><td>Joins an existing lobby.  This is an asynchronous request so please use <a href='#Lobby:onJoin'>Lobby:onJoin</a> or provide a callback function.</td></tr>
<tr><td><a href='#Lobby:leave'>Lobby:leave</a>()</td><td>Leave a lobby that the user is currently in; this will take effect immediately on the client side.</td></tr>
<tr><td><a href='#Lobby:onCreate'>Lobby:onCreate</a>()</td><td>Callback triggered after creating a new lobby.</td></tr>
<tr><td><a href='#Lobby:onJoin'>Lobby:onJoin</a>()</td><td>Callback triggered after joining a lobby.</td></tr>
<tr><td><a href='#Lobby:requestData'>Lobby:requestData</a>()</td><td>Refreshes all of the metadata for a lobby that you're not in right now.  You will never do this for lobbies you're a member of, that data will always be up to date.  You can use this to refresh lobbies that you have obtained from RequestLobbyList or that are available via friends.</td></tr>
<tr><td><a href='#Lobby:sendChatMessage'>Lobby:sendChatMessage</a>(<span class='arg'>msg</span>)</td><td>Sends a chat message to the lobby chat room.</td></tr>
<tr><td><a href='#Lobby:setData'>Lobby:setData</a>(<span class='arg'>key</span>, <span class='arg'>value</span>)</td><td>Set lobby metadata.</td></tr>
<tr><td><a href='#Lobby:setJoinable'>Lobby:setJoinable</a>(<span class='arg'>joinable</span>)</td><td>Sets whether or not a lobby is joinable by other players. This always defaults to enabled for a new lobby.  If joining is disabled, then no players can join, even if they are a friend or have been invited.  Lobbies with joining disabled will not be returned from a lobby search.</td></tr>
<tr><td><a href='#Lobby:setLimit'>Lobby:setLimit</a>(<span class='arg'>Number</span>)</td><td>Set the maximum number of players that can join the lobby.</td></tr>
<tr><td><a href='#Lobby:setOwner'>Lobby:setOwner</a>(<span class='arg'>owner</span>)</td><td>Changes the lobby owner.  This can only be set by the owner of the lobby.</td></tr>
<tr><td><a href='#Lobby:setType'>Lobby:setType</a>(<span class='arg'>kind</span>)</td><td>Updates the lobby type.  "private" means that the only way to join the lobby is from an invite.  "friends" means that the lobby is joinable by friends and invitees.  "public" means that the lobby will show in search.  "invisible" means that the lobby will show in search, but is not visible to other friends.  This is useful if you want a user in two lobbies, for example matching groups together.  A user can be in only one regular lobby, and up to two invisible lobbies.</td></tr>
</table>
<h3 id='Lobby:create'>Lobby:create(<span class='arg'>kind</span>, <span class='arg'>limit</span>, <span class='arg'>func</span>)</h3>
This is an internal function.  Please use <a href='#steam.newLobby'>steam.newLobby</a> instead.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>kind</b> (public)<br>
Kind of lobby: "private", "friends", "public" or "invisible"</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>limit</b> (250)<br>
Maximum number of users allowed to join the lobby.</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the lobby is created</td></tr>
</table>
<div class='see'>See: <a href='#steam.newLobby'>steam.newLobby</a></div>
<h3 id='Lobby:deleteData'>Lobby:deleteData(<span class='arg'>key</span>)</h3>
Removes lobby metadata.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>key</b><br>
Key</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:setData'>Lobby:setData</a>, <a href='#Lobby:getData'>Lobby:getData</a>, <a href='#Lobby:requestData'>Lobby:requestData</a></div>
<h3 id='Lobby:getChatMessage'>Lobby:getChatMessage(<span class='arg'>index</span>)</h3>
Gets message from the lobby chat room.  Chat messages are indexed by number.
<table>
<tr><td><a class='type'>number</a></td><td><b class='arg'>index</b><br>
Chat message index</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>String message</td></tr>
<tr><td><a href='#User' class='type'>User</a></td>
<td>Message author</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:getChatMessageCount'>Lobby:getChatMessageCount</a></div>
<h3 id='Lobby:getChatMessageCount'>Lobby:getChatMessageCount()</h3>
Gets the total number of messages in the lobby chat room.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>Number of messages</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:getChatMessage'>Lobby:getChatMessage</a></div>
<h3 id='Lobby:getData'>Lobby:getData(<span class='arg'>key</span>, <span class='arg'>user</span>)</h3>
Get lobby metadata.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>key</b><br>
Key</td></tr>
<tr><td><a href='#User' class='type'>User</a></td><td><b class='arg'>user</b> (optional)<br>
User for member data</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Value</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:setData'>Lobby:setData</a>, <a href='#Lobby:deleteData'>Lobby:deleteData</a>, <a href='#Lobby:requestData'>Lobby:requestData</a></div>
<h3 id='Lobby:getLimit'>Lobby:getLimit()</h3>
Get the current limit on the number of users who can join the lobby.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>Number of users who can join the lobby</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:setLimit'>Lobby:setLimit</a></div>
<h3 id='Lobby:getMembers'>Lobby:getMembers()</h3>
Returns a list of members who have joined the lobby.  The current user must be in the lobby to retrieve the Steam IDs of other users in that lobby.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>table</a></td>
<td>List of <a href='#User'>User</a> objects</td></tr>
</table>
<h3 id='Lobby:getOwner'>Lobby:getOwner()</h3>
Returns the lobby owner
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#User' class='type'>User</a></td>
<td>User object or nil if you aren"t a member of the lobby</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:setOwner'>Lobby:setOwner</a></div>
<h3 id='Lobby:init'>Lobby:init(<span class='arg'>id</span>)</h3>
This is an internal function.  Please use <a href='#steam.getLobby'>steam.getLobby</a> instead.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>id</b><br>
ID of an existing lobby</td></tr>
</table>
<div class='see'>See: <a href='#steam.getLobby'>steam.getLobby</a></div>
<h3 id='Lobby:invite'>Lobby:invite(<span class='arg'>friend</span>)</h3>
Invite another user to the lobby.  Shows a list of friends if no specific user is provided.
<table>
<tr><td><a href='#User' class='type'>User</a></td><td><b class='arg'>friend</b> (optional)<br>
The user who will be invited</td></tr>
</table>
<div class='see'>See: <a href='#User:inviteToGame'>User:inviteToGame</a></div>
<h3 id='Lobby:join'>Lobby:join(<span class='arg'>func</span>)</h3>
Joins an existing lobby.  This is an asynchronous request so please use <a href='#Lobby:onJoin'>Lobby:onJoin</a> or provide a callback function.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered after subscribing</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:onJoin'>Lobby:onJoin</a>, <a href='#Lobby:setJoinable'>Lobby:setJoinable</a>, <a href='#Lobby:leave'>Lobby:leave</a></div>
<h3 id='Lobby:leave'>Lobby:leave()</h3>
Leave a lobby that the user is currently in; this will take effect immediately on the client side.
<div class='see'>See: <a href='#Lobby:join'>Lobby:join</a></div>
<h3 id='Lobby:onCreate'>Lobby:onCreate()</h3>
Callback triggered after creating a new lobby.
<div class='see'>See: <a href='#steam.newLobby'>steam.newLobby</a></div>
<h3 id='Lobby:onJoin'>Lobby:onJoin()</h3>
Callback triggered after joining a lobby.
<div class='see'>See: <a href='#Lobby:join'>Lobby:join</a></div>
<h3 id='Lobby:requestData'>Lobby:requestData()</h3>
Refreshes all of the metadata for a lobby that you're not in right now.  You will never do this for lobbies you're a member of, that data will always be up to date.  You can use this to refresh lobbies that you have obtained from RequestLobbyList or that are available via friends.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:getData'>Lobby:getData</a>, <a href='#Lobby:setData'>Lobby:setData</a>, <a href='#Lobby:deleteData'>Lobby:deleteData</a></div>
<h3 id='Lobby:sendChatMessage'>Lobby:sendChatMessage(<span class='arg'>msg</span>)</h3>
Sends a chat message to the lobby chat room.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>msg</b><br>
Message</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the message was successfully sent</td></tr>
</table>
<h3 id='Lobby:setData'>Lobby:setData(<span class='arg'>key</span>, <span class='arg'>value</span>)</h3>
Set lobby metadata.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>key</b><br>
Key</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>value</b><br>
Value</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:getData'>Lobby:getData</a>, <a href='#Lobby:deleteData'>Lobby:deleteData</a>, <a href='#Lobby:requestData'>Lobby:requestData</a></div>
<h3 id='Lobby:setJoinable'>Lobby:setJoinable(<span class='arg'>joinable</span>)</h3>
Sets whether or not a lobby is joinable by other players. This always defaults to enabled for a new lobby.  If joining is disabled, then no players can join, even if they are a friend or have been invited.  Lobbies with joining disabled will not be returned from a lobby search.
<table>
<tr><td><a class='type'>boolean</a></td><td><b class='arg'>joinable</b><br>
Determines if the lobby can be joined</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:join'>Lobby:join</a></div>
<h3 id='Lobby:setLimit'>Lobby:setLimit(<span class='arg'>Number</span>)</h3>
Set the maximum number of players that can join the lobby.
<table>
<tr><td><a class='type'>number</a></td><td><b class='arg'>Number</b><br>
of users who can join the lobby</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:getLimit'>Lobby:getLimit</a></div>
<h3 id='Lobby:setOwner'>Lobby:setOwner(<span class='arg'>owner</span>)</h3>
Changes the lobby owner.  This can only be set by the owner of the lobby.
<table>
<tr><td><a href='#User' class='type'>User</a></td><td><b class='arg'>owner</b><br>
The new lobby owner</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:getOwner'>Lobby:getOwner</a></div>
<h3 id='Lobby:setType'>Lobby:setType(<span class='arg'>kind</span>)</h3>
Updates the lobby type.  "private" means that the only way to join the lobby is from an invite.  "friends" means that the lobby is joinable by friends and invitees.  "public" means that the lobby will show in search.  "invisible" means that the lobby will show in search, but is not visible to other friends.  This is useful if you want a user in two lobbies, for example matching groups together.  A user can be in only one regular lobby, and up to two invisible lobbies.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>kind</b> (public)<br>
Kind of lobby: "private", "friends", "public" or "invisible"</td></tr>
</table>
<br><br><br><h2 id='Socket'>Socket</h2>
The Socket object establishes peer-to-peer connections and sends data between clients.<br>
<table>
<tr><th colspan=2>Handle</th></tr>
<tr><td><a href='#Handle:callback'>Handle:callback</a>(<span class='arg'>func</span>, <span class='arg'>result</span>, <span class='arg'>...</span>)</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:new'>Handle:new</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:onError'>Handle:onError</a>(<span class='arg'>message</span>)</td><td>This callback is triggered when any requests fails.</td></tr>
<tr><td><a href='#Handle:setId'>Handle:setId</a>(<span class='arg'>handle</span>)</td><td>This is an internal function.</td></tr>
<tr><th colspan=2>Socket</th></tr>
<tr><td><a href='#Socket:destroy'>Socket:destroy</a>()</td><td>Destroys the socket closing any open connections.  All subsequent calls to this object will fail.</td></tr>
<tr><td><a href='#Socket:getAddress'>Socket:getAddress</a>(<span class='arg'>peer</span>)</td><td>Finds the remote address of the peer.  This is used for debugging purposes.</td></tr>
<tr><td><a href='#Socket:getId'>Socket:getId</a>()</td><td>Returns the channel number of the socket.</td></tr>
<tr><td><a href='#Socket:getPeer'>Socket:getPeer</a>()</td><td>Gets the peer associated this Socket object.</td></tr>
<tr><td><a href='#Socket:init'>Socket:init</a>(<span class='arg'>channel</span>, <span class='arg'>kind</span>)</td><td>This is an internal function.  Please use <a href='#steam.getSocket'>steam.getSocket</a> instead.</td></tr>
<tr><td><a href='#Socket:isConnected'>Socket:isConnected</a>(<span class='arg'>peer</span>)</td><td>Checks if there is an active and open connection with the peer.</td></tr>
<tr><td><a href='#Socket:receive'>Socket:receive</a>()</td><td>Receives data from the peer if available.  This call is not blocking and will return nil if no data is available.</td></tr>
<tr><td><a href='#Socket:send'>Socket:send</a>(<span class='arg'>data</span>, <span class='arg'>user</span>)</td><td>Sends data to the peer.</td></tr>
<tr><td><a href='#Socket:setPeer'>Socket:setPeer</a>(<span class='arg'>peer</span>)</td><td>Sets the peer associated this Socket object.  Both sides have to set each other as peers in order to establish a real P2P connection.</td></tr>
<tr><td><a href='#Socket:setProtocol'>Socket:setProtocol</a>(<span class='arg'>protocol</span>)</td><td>Sets the P2P protocol for the socket.  "unreliable" is basic UDP where packets can be lost, or in rare cases arrive out of order.  In case of connection problems, packet are batched until the connection is re-opened again.  "nodelay" is the same as the previous, but if the underlying P2P connection isn't yet established the packet will be thrown away.  "reliable" ensures that that the packets will always arrive in order. This is slower and allows sending larger messages efficiently.   "buffered" is the same as the previous, but messages will accumulate and be send together in one packet.  This is slower but allows you to send a set of smaller messages reliably.</td></tr>
</table>
<h3 id='Socket:destroy'>Socket:destroy()</h3>
Destroys the socket closing any open connections.  All subsequent calls to this object will fail.
<h3 id='Socket:getAddress'>Socket:getAddress(<span class='arg'>peer</span>)</h3>
Finds the remote address of the peer.  This is used for debugging purposes.
<table>
<tr><td><a href='#User' class='type'>User</a></td><td><b class='arg'>peer</b> (optional)<br>
User, if different from the peer</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>IP address of the peer (in IPv4 format)</td></tr>
<tr><td><a class='type'>number</a></td>
<td>Port number</td></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if using a Steam relay server</td></tr>
</table>
<h3 id='Socket:getId'>Socket:getId()</h3>
Returns the channel number of the socket.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>Channel number</td></tr>
</table>
<h3 id='Socket:getPeer'>Socket:getPeer()</h3>
Gets the peer associated this Socket object.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#User' class='type'>User</a></td>
<td>Peer</td></tr>
</table>
<div class='see'>See: <a href='#Socket:setPeer'>Socket:setPeer</a></div>
<h3 id='Socket:init'>Socket:init(<span class='arg'>channel</span>, <span class='arg'>kind</span>)</h3>
This is an internal function.  Please use <a href='#steam.getSocket'>steam.getSocket</a> instead.
<table>
<tr><td><a class='type'>number</a></td><td><b class='arg'>channel</b> (0)<br>
Channel number</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>kind</b> ("unreliable")<br>
Kind of socket: "unreliable", "nodelay", "reliable" or "buffered"</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a href='#Socket' class='type'>Socket</a></td>
<td>Socket object</td></tr>
</table>
<div class='see'>See: <a href='#steam.getSocket'>steam.getSocket</a></div>
<h3 id='Socket:isConnected'>Socket:isConnected(<span class='arg'>peer</span>)</h3>
Checks if there is an active and open connection with the peer.
<table>
<tr><td><a href='#User' class='type'>User</a></td><td><b class='arg'>peer</b> (optional)<br>
User, if different from the peer</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if connected</td></tr>
</table>
<h3 id='Socket:receive'>Socket:receive()</h3>
Receives data from the peer if available.  This call is not blocking and will return nil if no data is available.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Incoming message</td></tr>
<tr><td><a href='#User' class='type'>User</a></td>
<td>Sender, usually the same as the peer</td></tr>
</table>
<div class='see'>See: <a href='#Socket:send'>Socket:send</a></div>
<h3 id='Socket:send'>Socket:send(<span class='arg'>data</span>, <span class='arg'>user</span>)</h3>
Sends data to the peer.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>data</b><br>
Outgoing message</td></tr>
<tr><td><a href='#User' class='type'>User</a></td><td><b class='arg'>user</b> (optional)<br>
Receiver, if different from the peer</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the message was sent</td></tr>
</table>
<div class='see'>See: <a href='#Socket:receive'>Socket:receive</a></div>
<h3 id='Socket:setPeer'>Socket:setPeer(<span class='arg'>peer</span>)</h3>
Sets the peer associated this Socket object.  Both sides have to set each other as peers in order to establish a real P2P connection.
<table>
<tr><td><a href='#User' class='type'>User</a></td><td><b class='arg'>peer</b><br>
User that we want to connect with</td></tr>
</table>
<div class='see'>See: <a href='#Socket:getPeer'>Socket:getPeer</a></div>
<h3 id='Socket:setProtocol'>Socket:setProtocol(<span class='arg'>protocol</span>)</h3>
Sets the P2P protocol for the socket.  "unreliable" is basic UDP where packets can be lost, or in rare cases arrive out of order.  In case of connection problems, packet are batched until the connection is re-opened again.  "nodelay" is the same as the previous, but if the underlying P2P connection isn't yet established the packet will be thrown away.  "reliable" ensures that that the packets will always arrive in order. This is slower and allows sending larger messages efficiently.   "buffered" is the same as the previous, but messages will accumulate and be send together in one packet.  This is slower but allows you to send a set of smaller messages reliably.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>protocol</b><br>
Protocol kind: "unreliable", "nodelay", "reliable" or "buffered"</td></tr>
</table>
<br><br><br><h2 id='UGC'>UGC</h2>
The Steam Workshop is designed as a place for your fans and community members to participate in the creation of content for your game.
 The form of this creation by community members can vary depending on the nature of the game and what kind of control you wish to have over the content in your game.<br>
<table>
<tr><th colspan=2>Handle</th></tr>
<tr><td><a href='#Handle:callback'>Handle:callback</a>(<span class='arg'>func</span>, <span class='arg'>result</span>, <span class='arg'>...</span>)</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:destroy'>Handle:destroy</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:getId'>Handle:getId</a>()</td><td>Returns the unique Steam ID as a string.</td></tr>
<tr><td><a href='#Handle:new'>Handle:new</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:onError'>Handle:onError</a>(<span class='arg'>message</span>)</td><td>This callback is triggered when any requests fails.</td></tr>
<tr><td><a href='#Handle:setId'>Handle:setId</a>(<span class='arg'>handle</span>)</td><td>This is an internal function.</td></tr>
<tr><th colspan=2>UGC</th></tr>
<tr><td><a href='#UGC:create'>UGC:create</a>(<span class='arg'>kind</span>, <span class='arg'>appid</span>, <span class='arg'>func</span>)</td><td>This is an internal function.  Please use <a href='#steam.newUGC'>steam.newUGC</a> instead.</td></tr>
<tr><td><a href='#UGC:delete'>UGC:delete</a>(<span class='arg'>func</span>)</td><td>Deletes the item without prompting the user.</td></tr>
<tr><td><a href='#UGC:download'>UGC:download</a>()</td><td>Requests a download or update for a workshop item.  If the user is not subscribed to the item,  the workshop item will be downloaded and cached temporarily.</td></tr>
<tr><td><a href='#UGC:fetch'>UGC:fetch</a>(<span class='arg'>func</span>)</td><td>Fetches metadata about a user-generated item.  This is an asynchronous request so please use <a href='#UGC:onFetch'>UGC:onFetch</a> or provide a callback function to receive the results.</td></tr>
<tr><td><a href='#UGC:getDetails'>UGC:getDetails</a>(<span class='arg'>query</span>, <span class='arg'>index</span>)</td><td>This is an internal function.  Please use <a href='#UGC:fetch'>UGC:fetch</a> instead.</td></tr>
<tr><td><a href='#UGC:getDownloadInfo'>UGC:getDownloadInfo</a>()</td><td>Get info about the pending download of a workshop item.</td></tr>
<tr><td><a href='#UGC:getInstallInfo'>UGC:getInstallInfo</a>()</td><td>Gets info about currently installed content on the disc for workshop items.  Calling this sets the "used" flag on the workshop item for the current player and adds it to their "used or played" list.</td></tr>
<tr><td><a href='#UGC:init'>UGC:init</a>(<span class='arg'>id</span>, <span class='arg'>appid</span>)</td><td>This is an internal function.  Please use <a href='#steam.getUGC'>steam.getUGC</a> instead.</td></tr>
<tr><td><a href='#UGC:isInstalled'>UGC:isInstalled</a>()</td><td>Checks if this workshop item is downloaded and installed on the client.</td></tr>
<tr><td><a href='#UGC:onCreate'>UGC:onCreate</a>()</td><td>Callback triggered when the user-generated item is created.</td></tr>
<tr><td><a href='#UGC:onDelete'>UGC:onDelete</a>()</td><td>Callback triggered after deleting the item.</td></tr>
<tr><td><a href='#UGC:onFetch'>UGC:onFetch</a>(<span class='arg'>data</span>)</td><td>Callback triggered after fetching the item's metadata.</td></tr>
<tr><td><a href='#UGC:onStartTracking'>UGC:onStartTracking</a>()</td><td>Callback triggered when starting to track the user-generated item.</td></tr>
<tr><td><a href='#UGC:onStopTracking'>UGC:onStopTracking</a>()</td><td>Callback triggered when stopping to track the user-generated item.</td></tr>
<tr><td><a href='#UGC:onSubscribe'>UGC:onSubscribe</a>()</td><td>Callback triggered after subscribing to the user-generated item.</td></tr>
<tr><td><a href='#UGC:onUpdate'>UGC:onUpdate</a>(<span class='arg'>agree</span>)</td><td>Callback triggered after updating the item.</td></tr>
<tr><td><a href='#UGC:startTracking'>UGC:startTracking</a>(<span class='arg'>func</span>)</td><td>Start tracking playtime on a set of workshop items.  When your app shuts down, playtime tracking will automatically stop.</td></tr>
<tr><td><a href='#UGC:stopTracking'>UGC:stopTracking</a>(<span class='arg'>func</span>)</td><td>Stops tracking playtime on a set of workshop items.</td></tr>
<tr><td><a href='#UGC:subscribe'>UGC:subscribe</a>(<span class='arg'>func</span>)</td><td>Subscribe to a workshop item. This will also downloaded and install the item as soon as possible.  This is an asynchronous request so please use <a href='#UGC:onSubscribe'>UGC:onSubscribe</a> or provide a callback function.</td></tr>
<tr><td><a href='#UGC:update'>UGC:update</a>(<span class='arg'>path</span>, <span class='arg'>data</span>, <span class='arg'>note</span>, <span class='arg'>func</span>)</td><td>Uploads the changes made to an item to the Steam Workshop.</td></tr>
</table>
<h3 id='UGC:create'>UGC:create(<span class='arg'>kind</span>, <span class='arg'>appid</span>, <span class='arg'>func</span>)</h3>
This is an internal function.  Please use <a href='#steam.newUGC'>steam.newUGC</a> instead.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>kind</b> ("community")<br>
Type of object: "community", "micro", "collection", "art", "video", "screenshot", "game", "software", "concept", "webguide", "guide", "merch", "binding", "accessinvite", "steamvideo" or "managed".</td></tr>
<tr><td><a class='type'>value</a></td><td><b class='arg'>appid</b> (optional)<br>
AppID if different from the base game</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when the item is created</td></tr>
</table>
<div class='see'>See: <a href='#steam.newUGC'>steam.newUGC</a></div>
<h3 id='UGC:delete'>UGC:delete(<span class='arg'>func</span>)</h3>
Deletes the item without prompting the user.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered after deleting the item</td></tr>
</table>
<div class='see'>See: <a href='#UGC:onDelete'>UGC:onDelete</a></div>
<h3 id='UGC:download'>UGC:download()</h3>
Requests a download or update for a workshop item.  If the user is not subscribed to the item,  the workshop item will be downloaded and cached temporarily.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the download was started</td></tr>
</table>
<div class='see'>See: <a href='#UGC:getDownloadInfo'>UGC:getDownloadInfo</a></div>
<h3 id='UGC:fetch'>UGC:fetch(<span class='arg'>func</span>)</h3>
Fetches metadata about a user-generated item.  This is an asynchronous request so please use <a href='#UGC:onFetch'>UGC:onFetch</a> or provide a callback function to receive the results.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback triggered after fetching the item's metadata</td></tr>
</table>
<div class='see'>See: <a href='#UGC:onFetch'>UGC:onFetch</a></div>
<h3 id='UGC:getDetails'>UGC:getDetails(<span class='arg'>query</span>, <span class='arg'>index</span>)</h3>
This is an internal function.  Please use <a href='#UGC:fetch'>UGC:fetch</a> instead.
<table>
<tr><td><a href='#cdata' class='type'>cdata</a></td><td><b class='arg'>query</b><br>
Query object</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>index</b><br>
Index number</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>table</a></td>
<td>Metadata table</td></tr>
</table>
<h3 id='UGC:getDownloadInfo'>UGC:getDownloadInfo()</h3>
Get info about the pending download of a workshop item.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>Downloaded bytes</td></tr>
<tr><td><a class='type'>number</a></td>
<td>Total bytes</td></tr>
</table>
<div class='see'>See: <a href='#UGC:download'>UGC:download</a></div>
<h3 id='UGC:getInstallInfo'>UGC:getInstallInfo()</h3>
Gets info about currently installed content on the disc for workshop items.  Calling this sets the "used" flag on the workshop item for the current player and adds it to their "used or played" list.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Directory path to the installed content</td></tr>
<tr><td><a class='type'>number</a></td>
<td>Size in bytes</td></tr>
<tr><td><a class='type'>number</a></td>
<td>Timestamp of when it was installed</td></tr>
</table>
<div class='see'>See: <a href='#UGC:isInstalled'>UGC:isInstalled</a></div>
<h3 id='UGC:init'>UGC:init(<span class='arg'>id</span>, <span class='arg'>appid</span>)</h3>
This is an internal function.  Please use <a href='#steam.getUGC'>steam.getUGC</a> instead.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>id</b><br>
ID of an existing user-generated item </td></tr>
<tr><td><a class='type'>value</a></td><td><b class='arg'>appid</b> (optional)<br>
AppID if different from the base game</td></tr>
</table>
<div class='see'>See: <a href='#steam.getUGC'>steam.getUGC</a></div>
<h3 id='UGC:isInstalled'>UGC:isInstalled()</h3>
Checks if this workshop item is downloaded and installed on the client.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if installed</td></tr>
</table>
<div class='see'>See: <a href='#UGC:getInstallInfo'>UGC:getInstallInfo</a></div>
<h3 id='UGC:onCreate'>UGC:onCreate()</h3>
Callback triggered when the user-generated item is created.
<div class='see'>See: <a href='#steam.newUGC'>steam.newUGC</a></div>
<h3 id='UGC:onDelete'>UGC:onDelete()</h3>
Callback triggered after deleting the item.
<div class='see'>See: <a href='#UGC:delete'>UGC:delete</a></div>
<h3 id='UGC:onFetch'>UGC:onFetch(<span class='arg'>data</span>)</h3>
Callback triggered after fetching the item's metadata.
<table>
<tr><td><a class='type'>table</a></td><td><b class='arg'>data</b><br>
Table of fetched metadata</td></tr>
</table>
<div class='see'>See: <a href='#UGC:fetch'>UGC:fetch</a></div>
<h3 id='UGC:onStartTracking'>UGC:onStartTracking()</h3>
Callback triggered when starting to track the user-generated item.
<div class='see'>See: <a href='#UGC:startTracking'>UGC:startTracking</a></div>
<h3 id='UGC:onStopTracking'>UGC:onStopTracking()</h3>
Callback triggered when stopping to track the user-generated item.
<div class='see'>See: <a href='#UGC:stopTracking'>UGC:stopTracking</a></div>
<h3 id='UGC:onSubscribe'>UGC:onSubscribe()</h3>
Callback triggered after subscribing to the user-generated item.
<div class='see'>See: <a href='#UGC:subscribe'>UGC:subscribe</a></div>
<h3 id='UGC:onUpdate'>UGC:onUpdate(<span class='arg'>agree</span>)</h3>
Callback triggered after updating the item.
<table>
<tr><td><a class='type'>boolean</a></td><td><b class='arg'>agree</b><br>
True if the user needs to accept the workshop legal agreement</td></tr>
</table>
<div class='see'>See: <a href='#UGC:update'>UGC:update</a></div>
<h3 id='UGC:startTracking'>UGC:startTracking(<span class='arg'>func</span>)</h3>
Start tracking playtime on a set of workshop items.  When your app shuts down, playtime tracking will automatically stop.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when starting to track time</td></tr>
</table>
<div class='see'>See: <a href='#UGC:stopTracking'>UGC:stopTracking</a>, <a href='#UGC:onStartTracking'>UGC:onStartTracking</a></div>
<h3 id='UGC:stopTracking'>UGC:stopTracking(<span class='arg'>func</span>)</h3>
Stops tracking playtime on a set of workshop items.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered when stopping to track time</td></tr>
</table>
<div class='see'>See: <a href='#UGC:startTracking'>UGC:startTracking</a>, <a href='#UGC:onStopTracking'>UGC:onStopTracking</a></div>
<h3 id='UGC:subscribe'>UGC:subscribe(<span class='arg'>func</span>)</h3>
Subscribe to a workshop item. This will also downloaded and install the item as soon as possible.  This is an asynchronous request so please use <a href='#UGC:onSubscribe'>UGC:onSubscribe</a> or provide a callback function.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback function triggered after subscribing</td></tr>
</table>
<div class='see'>See: <a href='#UGC:onSubscribe'>UGC:onSubscribe</a>, <a href='#steam.getSubscribedUGC'>steam.getSubscribedUGC</a></div>
<h3 id='UGC:update'>UGC:update(<span class='arg'>path</span>, <span class='arg'>data</span>, <span class='arg'>note</span>, <span class='arg'>func</span>)</h3>
Uploads the changes made to an item to the Steam Workshop.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>path</b><br>
Directory path that will be uploaded</td></tr>
<tr><td><a class='type'>table</a></td><td><b class='arg'>data</b><br>
Metadata associated with the item</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>note</b> (optional)<br>
Update note</td></tr>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b> (optional)<br>
Callback triggered after updating the item</td></tr>
</table>
<div class='see'>See: <a href='#UGC:onUpdate'>UGC:onUpdate</a></div>
<br><br><br><h2 id='User'>User</h2>
User objects handle avatars, stats, achievements and other personal data.<br>
<table>
<tr><th colspan=2>Handle</th></tr>
<tr><td><a href='#Handle:callback'>Handle:callback</a>(<span class='arg'>func</span>, <span class='arg'>result</span>, <span class='arg'>...</span>)</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:destroy'>Handle:destroy</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:getId'>Handle:getId</a>()</td><td>Returns the unique Steam ID as a string.</td></tr>
<tr><td><a href='#Handle:new'>Handle:new</a>()</td><td>This is an internal function.</td></tr>
<tr><td><a href='#Handle:onError'>Handle:onError</a>(<span class='arg'>message</span>)</td><td>This callback is triggered when any requests fails.</td></tr>
<tr><td><a href='#Handle:setId'>Handle:setId</a>(<span class='arg'>handle</span>)</td><td>This is an internal function.</td></tr>
<tr><th colspan=2>User</th></tr>
<tr><td><a href='#User:activateOverlay'>User:activateOverlay</a>(<span class='arg'>dialog</span>)</td><td>Opens the user's profile in the game overlay.</td></tr>
<tr><td><a href='#User:cancelAuthTicket'>User:cancelAuthTicket</a>(<span class='arg'>ticket</span>)</td><td>Cancels an auth ticket received from <a href='#User:getAuthTicket'>User:getAuthTicket</a>.  This should be called when no longer playing with the specified entity.</td></tr>
<tr><td><a href='#User:clearAchievement'>User:clearAchievement</a>(<span class='arg'>stat</span>)</td><td>Resets the unlock status of an achievement.  This is primarily only ever used for testing.</td></tr>
<tr><td><a href='#User:clearRichPresence'>User:clearRichPresence</a>()</td><td>Clears all previously set Rich Presence keys.</td></tr>
<tr><td><a href='#User:getAchievement'>User:getAchievement</a>(<span class='arg'>ach</span>)</td><td>Gets the achievement status, and the time it was unlocked if unlocked.  If the return value is true, but the unlock time is zero, that means it was unlocked before Steam began tracking achievement unlock times (December 2009). The time is provided in Unix epoch format, seconds since January 1, 1970 UTC.</td></tr>
<tr><td><a href='#User:getAuthTicket'>User:getAuthTicket</a>()</td><td>Retrieve an authentication ticket to be sent to the entity who wishes to authenticate you.</td></tr>
<tr><td><a href='#User:getAvatar'>User:getAvatar</a>(<span class='arg'>size</span>)</td><td>Returns an avatar if it's cached.  Avatars are usually cached for the owner and his friends,  but you may need to call <a href='#User:requestAvatar'>User:requestAvatar</a> for other users.</td></tr>
<tr><td><a href='#User:getGamePlayed'>User:getGamePlayed</a>()</td><td>Checks if the specified friend is in a game, and gets info about the game if they are.</td></tr>
<tr><td><a href='#User:getLevel'>User:getLevel</a>()</td><td>Gets the user's Steam level if available, otherwise it queues the Steam level for download.</td></tr>
<tr><td><a href='#User:getName'>User:getName</a>()</td><td>Returns the persona name of the user.  The persona name can be changed and can contain UTF-8 characters.</td></tr>
<tr><td><a href='#User:getPlayedWith'>User:getPlayedWith</a>()</td><td>Gets the app ID of the game that user played with someone on their recently-played-with list.</td></tr>
<tr><td><a href='#User:getRichPresence'>User:getRichPresence</a>(<span class='arg'>key</span>)</td><td>Sets a Rich Presence value for a key.</td></tr>
<tr><td><a href='#User:getStat'>User:getStat</a>(<span class='arg'>stat</span>)</td><td>Gets the current value of the a stat for the specified user.  You must have called <a href='#User:requestCurrentStats'>User:requestCurrentStats</a> and it needs to return successfully via its callback prior to calling this!</td></tr>
<tr><td><a href='#User:init'>User:init</a>(<span class='arg'>id</span>)</td><td>This is an internal function.  Please use <a href='#steam.getUser'>steam.getUser</a> instead.</td></tr>
<tr><td><a href='#User:inviteToGame'>User:inviteToGame</a>(<span class='arg'>msg</span>)</td><td>Invites a friend or clan member to the current game using a special invite string.  If the target user accepts the invite then the invite string gets added to the command-line when launching the game.</td></tr>
<tr><td><a href='#User:isFriend'>User:isFriend</a>()</td><td>Checks the user is friends with the owner.</td></tr>
<tr><td><a href='#User:isOnline'>User:isOnline</a>()</td><td>Checks the user's status among friends.</td></tr>
<tr><td><a href='#User:isOwner'>User:isOwner</a>()</td><td>Checks if the user is the current owner.</td></tr>
<tr><td><a href='#User:onReceiveStats'>User:onReceiveStats</a>()</td><td>Callback triggered when the user stats are received from the server.</td></tr>
<tr><td><a href='#User:requestAvatar'>User:requestAvatar</a>()</td><td>Requests the avatar for caching.  It's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them.</td></tr>
<tr><td><a href='#User:requestCurrentStats'>User:requestCurrentStats</a>()</td><td>Asynchronously request the owner's current stats and achievements from the server.  The equivalent function for other users is <a href='#User:requestStats'>User:requestStats</a>.</td></tr>
<tr><td><a href='#User:requestName'>User:requestName</a>()</td><td>This is an internal function.  Requests that the user's persona name is fetched and cached locally.</td></tr>
<tr><td><a href='#User:requestRichPresence'>User:requestRichPresence</a>()</td><td>Requests the rich presence details for users who are not friends.</td></tr>
<tr><td><a href='#User:requestStats'>User:requestStats</a>(<span class='arg'>func</span>)</td><td>Asynchronously request the user's stats and achievements from the server.  This function triggers the <a href='#User:onReceiveStats'>User:onReceiveStats</a> callback.</td></tr>
<tr><td><a href='#User:resetStats'>User:resetStats</a>(<span class='arg'>ach</span>)</td><td>Resets all stats and achievements unlocked by the owner.</td></tr>
<tr><td><a href='#User:setAchievement'>User:setAchievement</a>(<span class='arg'>stat</span>)</td><td>Unlocks a specific attachment.  You must have called <a href='#User:requestCurrentStats'>User:requestCurrentStats</a> and it needs to return successfully via its callback prior to calling this!</td></tr>
<tr><td><a href='#User:setName'>User:setName</a>(<span class='arg'>name</span>)</td><td>Sets the persona name of the owner.</td></tr>
<tr><td><a href='#User:setPlayedWith'>User:setPlayedWith</a>()</td><td>Mark a target user as 'played with'.  The current user must be in game with the other player for the association to work.</td></tr>
<tr><td><a href='#User:setRichPresence'>User:setRichPresence</a>(<span class='arg'>key</span>, <span class='arg'>value</span>)</td><td>Sets a Rich Presence key/value for the current user that is automatically shared to all friends playing the same game.  Each user can have up to 20 keys set.</td></tr>
<tr><td><a href='#User:setStat'>User:setStat</a>(<span class='arg'>stat</span>, <span class='arg'>value</span>)</td><td>Sets or updates the value of a given stat for the current user.  You must have called <a href='#User:requestCurrentStats'>User:requestCurrentStats</a> and it needs to return successfully via its callback prior to calling this!</td></tr>
<tr><td><a href='#User:storeStats'>User:storeStats</a>()</td><td>Stores the user's stats and achievements on the server.</td></tr>
</table>
<h3 id='User:activateOverlay'>User:activateOverlay(<span class='arg'>dialog</span>)</h3>
Opens the user's profile in the game overlay.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>dialog</b><br>
Dialog options: "steamid", "chat", "jointrade", "stats", "achievements", "friendadd", "friendremove", "friendrequestaccept" or "friendrequestignore"</td></tr>
</table>
<div class='see'>See: <a href='#steam.activateOverlay'>steam.activateOverlay</a></div>
<h3 id='User:cancelAuthTicket'>User:cancelAuthTicket(<span class='arg'>ticket</span>)</h3>
Cancels an auth ticket received from <a href='#User:getAuthTicket'>User:getAuthTicket</a>.  This should be called when no longer playing with the specified entity.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>ticket</b><br>
Authentication ticket</td></tr>
</table>
<div class='see'>See: <a href='#User:getAuthTicket'>User:getAuthTicket</a></div>
<h3 id='User:clearAchievement'>User:clearAchievement(<span class='arg'>stat</span>)</h3>
Resets the unlock status of an achievement.  This is primarily only ever used for testing.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>stat</b><br>
Achievement name</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#User:getAchievement'>User:getAchievement</a>, <a href='#User:setAchievement'>User:setAchievement</a></div>
<h3 id='User:clearRichPresence'>User:clearRichPresence()</h3>
Clears all previously set Rich Presence keys.
<div class='see'>See: <a href='#User:getRichPresence'>User:getRichPresence</a>, <a href='#User:setRichPresence'>User:setRichPresence</a></div>
<h3 id='User:getAchievement'>User:getAchievement(<span class='arg'>ach</span>)</h3>
Gets the achievement status, and the time it was unlocked if unlocked.  If the return value is true, but the unlock time is zero, that means it was unlocked before Steam began tracking achievement unlock times (December 2009). The time is provided in Unix epoch format, seconds since January 1, 1970 UTC.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>ach</b><br>
Achievement name</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if unlocked</td></tr>
<tr><td><a class='type'>number</a></td>
<td>Timestamp of when it was unlocked</td></tr>
</table>
<div class='see'>See: <a href='#User:setAchievement'>User:setAchievement</a>, <a href='#User:clearAchievement'>User:clearAchievement</a></div>
<h3 id='User:getAuthTicket'>User:getAuthTicket()</h3>
Retrieve an authentication ticket to be sent to the entity who wishes to authenticate you.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Authentication ticket</td></tr>
</table>
<div class='see'>See: <a href='#User:cancelAuthTicket'>User:cancelAuthTicket</a></div>
<h3 id='User:getAvatar'>User:getAvatar(<span class='arg'>size</span>)</h3>
Returns an avatar if it's cached.  Avatars are usually cached for the owner and his friends,  but you may need to call <a href='#User:requestAvatar'>User:requestAvatar</a> for other users.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>size</b> ("medium")<br>
Image size: "small", "medium" or "large"</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Encoded image data of the avatar or nil</td></tr>
</table>
<div class='see'>See: <a href='#User:requestAvatar'>User:requestAvatar</a></div>
<h3 id='User:getGamePlayed'>User:getGamePlayed()</h3>
Checks if the specified friend is in a game, and gets info about the game if they are.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>AppID of the game your friend is playing</td></tr>
<tr><td><a href='#Lobby' class='type'>Lobby</a></td>
<td>The lobby that your friend has joined, if available</td></tr>
</table>
<div class='see'>See: <a href='#User:isOnline'>User:isOnline</a></div>
<h3 id='User:getLevel'>User:getLevel()</h3>
Gets the user's Steam level if available, otherwise it queues the Steam level for download.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>Steam level or 0 if unavailable</td></tr>
</table>
<h3 id='User:getName'>User:getName()</h3>
Returns the persona name of the user.  The persona name can be changed and can contain UTF-8 characters.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>Persona name</td></tr>
</table>
<div class='see'>See: <a href='#User:setName'>User:setName</a>, <a href='#User:requestName'>User:requestName</a></div>
<h3 id='User:getPlayedWith'>User:getPlayedWith()</h3>
Gets the app ID of the game that user played with someone on their recently-played-with list.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>AppID</td></tr>
<tr><td><a class='type'>number</a></td>
<td>Amount of co-play time</td></tr>
</table>
<div class='see'>See: <a href='#User:setPlayedWith'>User:setPlayedWith</a></div>
<h3 id='User:getRichPresence'>User:getRichPresence(<span class='arg'>key</span>)</h3>
Sets a Rich Presence value for a key.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>key</b><br>
Key string</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>string</a></td>
<td>value Value string</td></tr>
</table>
<div class='see'>See: <a href='#User:setRichPresence'>User:setRichPresence</a>, <a href='#User:clearRichPresence'>User:clearRichPresence</a>, <a href='#User:requestRichPresence'>User:requestRichPresence</a></div>
<h3 id='User:getStat'>User:getStat(<span class='arg'>stat</span>)</h3>
Gets the current value of the a stat for the specified user.  You must have called <a href='#User:requestCurrentStats'>User:requestCurrentStats</a> and it needs to return successfully via its callback prior to calling this!
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>stat</b><br>
Stat name</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>number</a></td>
<td>Stat value</td></tr>
</table>
<div class='see'>See: <a href='#User:setStat'>User:setStat</a>, <a href='#User:requestStats'>User:requestStats</a>, <a href='#User:requestCurrentStats'>User:requestCurrentStats</a></div>
<h3 id='User:init'>User:init(<span class='arg'>id</span>)</h3>
This is an internal function.  Please use <a href='#steam.getUser'>steam.getUser</a> instead.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>id</b> (optional)<br>
User ID in decimal format</td></tr>
</table>
<div class='see'>See: <a href='#steam.getUser'>steam.getUser</a></div>
<h3 id='User:inviteToGame'>User:inviteToGame(<span class='arg'>msg</span>)</h3>
Invites a friend or clan member to the current game using a special invite string.  If the target user accepts the invite then the invite string gets added to the command-line when launching the game.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>msg</b><br>
Invitation message</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the invite was successfully sent</td></tr>
</table>
<div class='see'>See: <a href='#Lobby:invite'>Lobby:invite</a></div>
<h3 id='User:isFriend'>User:isFriend()</h3>
Checks the user is friends with the owner.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if friends with the owner</td></tr>
</table>
<div class='see'>See: <a href='#steam.getFriends'>steam.getFriends</a></div>
<h3 id='User:isOnline'>User:isOnline()</h3>
Checks the user's status among friends.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if currently visible among friends</td></tr>
</table>
<div class='see'>See: <a href='#User:getGamePlayed'>User:getGamePlayed</a></div>
<h3 id='User:isOwner'>User:isOwner()</h3>
Checks if the user is the current owner.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if the user is the owner</td></tr>
</table>
<h3 id='User:onReceiveStats'>User:onReceiveStats()</h3>
Callback triggered when the user stats are received from the server.
<div class='see'>See: <a href='#User:requestStats'>User:requestStats</a></div>
<h3 id='User:requestAvatar'>User:requestAvatar()</h3>
Requests the avatar for caching.  It's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>False if the avatar is already cached</td></tr>
</table>
<div class='see'>See: <a href='#User:getAvatar'>User:getAvatar</a></div>
<h3 id='User:requestCurrentStats'>User:requestCurrentStats()</h3>
Asynchronously request the owner's current stats and achievements from the server.  The equivalent function for other users is <a href='#User:requestStats'>User:requestStats</a>.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>False if the avatar is already cached</td></tr>
</table>
<div class='see'>See: <a href='#User:getStat'>User:getStat</a>, <a href='#User:requestStats'>User:requestStats</a></div>
<h3 id='User:requestName'>User:requestName()</h3>
This is an internal function.  Requests that the user's persona name is fetched and cached locally.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>False if the persona name is already cached</td></tr>
</table>
<div class='see'>See: <a href='#User:getName'>User:getName</a>, <a href='#User:setName'>User:setName</a></div>
<h3 id='User:requestRichPresence'>User:requestRichPresence()</h3>
Requests the rich presence details for users who are not friends.
<div class='see'>See: <a href='#User:getRichPresence'>User:getRichPresence</a></div>
<h3 id='User:requestStats'>User:requestStats(<span class='arg'>func</span>)</h3>
Asynchronously request the user's stats and achievements from the server.  This function triggers the <a href='#User:onReceiveStats'>User:onReceiveStats</a> callback.
<table>
<tr><td><a class='type'>function</a></td><td><b class='arg'>func</b><br>
Callback function triggered when the stats are ready</td></tr>
</table>
<div class='see'>See: <a href='#User:getStat'>User:getStat</a>, <a href='#User:requestCurrentStats'>User:requestCurrentStats</a>, <a href='#User:onReceiveStats'>User:onReceiveStats</a></div>
<h3 id='User:resetStats'>User:resetStats(<span class='arg'>ach</span>)</h3>
Resets all stats and achievements unlocked by the owner.
<table>
<tr><td><a class='type'>boolean</a></td><td><b class='arg'>ach</b><br>
Determines if achievement data should be wiped too</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#User:storeStats'>User:storeStats</a></div>
<h3 id='User:setAchievement'>User:setAchievement(<span class='arg'>stat</span>)</h3>
Unlocks a specific attachment.  You must have called <a href='#User:requestCurrentStats'>User:requestCurrentStats</a> and it needs to return successfully via its callback prior to calling this!
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>stat</b><br>
Achievement name</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#User:getAchievement'>User:getAchievement</a>, <a href='#User:clearAchievement'>User:clearAchievement</a>, <a href='#User:storeStats'>User:storeStats</a></div>
<h3 id='User:setName'>User:setName(<span class='arg'>name</span>)</h3>
Sets the persona name of the owner.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>name</b><br>
New persona name</td></tr>
</table>
<div class='see'>See: <a href='#User:getName'>User:getName</a>, <a href='#User:requestName'>User:requestName</a></div>
<h3 id='User:setPlayedWith'>User:setPlayedWith()</h3>
Mark a target user as 'played with'.  The current user must be in game with the other player for the association to work.
<div class='see'>See: <a href='#User:getPlayedWith'>User:getPlayedWith</a>, <a href='#steam.getPlayedWith'>steam.getPlayedWith</a></div>
<h3 id='User:setRichPresence'>User:setRichPresence(<span class='arg'>key</span>, <span class='arg'>value</span>)</h3>
Sets a Rich Presence key/value for the current user that is automatically shared to all friends playing the same game.  Each user can have up to 20 keys set.
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>key</b><br>
Key string (where "status", "connect", "steam_display", "steam_player_group", "steam_player_group_size" are reserved)</td></tr>
<tr><td><a class='type'>string</a></td><td><b class='arg'>value</b><br>
Value string</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#User:clearRichPresence'>User:clearRichPresence</a>, <a href='#User:getRichPresence'>User:getRichPresence</a></div>
<h3 id='User:setStat'>User:setStat(<span class='arg'>stat</span>, <span class='arg'>value</span>)</h3>
Sets or updates the value of a given stat for the current user.  You must have called <a href='#User:requestCurrentStats'>User:requestCurrentStats</a> and it needs to return successfully via its callback prior to calling this!
<table>
<tr><td><a class='type'>string</a></td><td><b class='arg'>stat</b><br>
Stat name</td></tr>
<tr><td><a class='type'>number</a></td><td><b class='arg'>value</b><br>
Stat value</td></tr>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#User:getStat'>User:getStat</a>, <a href='#User:storeStats'>User:storeStats</a></div>
<h3 id='User:storeStats'>User:storeStats()</h3>
Stores the user's stats and achievements on the server.
<table>
<tr><th></td><th>Returns</th></tr>
<tr><td><a class='type'>boolean</a></td>
<td>True if successful</td></tr>
</table>
<div class='see'>See: <a href='#User:setStat'>User:setStat</a>, <a href='#User:resetStats'>User:resetStats</a></div>
<br><br><br></div>
<div class='menu'>
<h3><a href='#steam'>steam</a></h3>
<ul>
<li><a href='#steam.activateOverlay'>activateOverlay</a><br>
<li><a href='#steam.getAchievements'>getAchievements</a><br>
<li><a href='#steam.getAppId'>getAppId</a><br>
<li><a href='#steam.getBoard'>getBoard</a><br>
<li><a href='#steam.getClan'>getClan</a><br>
<li><a href='#steam.getClans'>getClans</a><br>
<li><a href='#steam.getCountry'>getCountry</a><br>
<li><a href='#steam.getFriends'>getFriends</a><br>
<li><a href='#steam.getLanguage'>getLanguage</a><br>
<li><a href='#steam.getLobby'>getLobby</a><br>
<li><a href='#steam.getPlayedWith'>getPlayedWith</a><br>
<li><a href='#steam.getSocket'>getSocket</a><br>
<li><a href='#steam.getSubscribedUGC'>getSubscribedUGC</a><br>
<li><a href='#steam.getUGC'>getUGC</a><br>
<li><a href='#steam.getUser'>getUser</a><br>
<li><a href='#steam.init'>init</a><br>
<li><a href='#steam.isBigPicture'>isBigPicture</a><br>
<li><a href='#steam.isConnected'>isConnected</a><br>
<li><a href='#steam.isRunning'>isRunning</a><br>
<li><a href='#steam.newBoard'>newBoard</a><br>
<li><a href='#steam.newLobby'>newLobby</a><br>
<li><a href='#steam.newUGC'>newUGC</a><br>
<li><a href='#steam.queryLobbies'>queryLobbies</a><br>
<li><a href='#steam.queryUGC'>queryUGC</a><br>
<li><a href='#steam.request'>request</a><br>
<li><a href='#steam.restart'>restart</a><br>
<li><a href='#steam.setNotificationPosition'>setNotificationPosition</a><br>
<li><a href='#steam.shutdown'>shutdown</a><br>
<li><a href='#steam.update'>update</a><br>
</ul>
<h3><a href='#Handle'>Handle</a></h3>
<ul>
<li><a href='#Handle:callback'>callback</a><br>
<li><a href='#Handle:destroy'>destroy</a><br>
<li><a href='#Handle:getId'>getId</a><br>
<li><a href='#Handle:new'>new</a><br>
<li><a href='#Handle:onError'>onError</a><br>
<li><a href='#Handle:setId'>setId</a><br>
</ul>
<h3><a href='#Board'>Board</a></h3>
<ul>
<li><a href='#Board:attach'>attach</a><br>
<li><a href='#Board:create'>create</a><br>
<li><a href='#Board:destroy'>destroy</a><br>
<li><a href='#Board:download'>download</a><br>
<li><a href='#Board:getEntryCount'>getEntryCount</a><br>
<li><a href='#Board:getName'>getName</a><br>
<li><a href='#Board:init'>init</a><br>
<li><a href='#Board:onAttach'>onAttach</a><br>
<li><a href='#Board:onCreate'>onCreate</a><br>
<li><a href='#Board:onDownload'>onDownload</a><br>
<li><a href='#Board:onFind'>onFind</a><br>
<li><a href='#Board:onUpload'>onUpload</a><br>
<li><a href='#Board:upload'>upload</a><br>
</ul>
<h3><a href='#Clan'>Clan</a></h3>
<ul>
<li><a href='#Clan:getActivity'>getActivity</a><br>
<li><a href='#Clan:getChatMembers'>getChatMembers</a><br>
<li><a href='#Clan:getChatMessage'>getChatMessage</a><br>
<li><a href='#Clan:getChatMessageCount'>getChatMessageCount</a><br>
<li><a href='#Clan:getName'>getName</a><br>
<li><a href='#Clan:getOfficers'>getOfficers</a><br>
<li><a href='#Clan:getOwner'>getOwner</a><br>
<li><a href='#Clan:init'>init</a><br>
<li><a href='#Clan:isOfficial'>isOfficial</a><br>
<li><a href='#Clan:isPublic'>isPublic</a><br>
<li><a href='#Clan:joinChat'>joinChat</a><br>
<li><a href='#Clan:leaveChat'>leaveChat</a><br>
<li><a href='#Clan:onJoinChat'>onJoinChat</a><br>
<li><a href='#Clan:onReceiveActivity'>onReceiveActivity</a><br>
<li><a href='#Clan:onReceiveOfficers'>onReceiveOfficers</a><br>
<li><a href='#Clan:requestActivity'>requestActivity</a><br>
<li><a href='#Clan:requestOfficers'>requestOfficers</a><br>
<li><a href='#Clan:sendChatMessage'>sendChatMessage</a><br>
</ul>
<h3><a href='#Lobby'>Lobby</a></h3>
<ul>
<li><a href='#Lobby:create'>create</a><br>
<li><a href='#Lobby:deleteData'>deleteData</a><br>
<li><a href='#Lobby:getChatMessage'>getChatMessage</a><br>
<li><a href='#Lobby:getChatMessageCount'>getChatMessageCount</a><br>
<li><a href='#Lobby:getData'>getData</a><br>
<li><a href='#Lobby:getLimit'>getLimit</a><br>
<li><a href='#Lobby:getMembers'>getMembers</a><br>
<li><a href='#Lobby:getOwner'>getOwner</a><br>
<li><a href='#Lobby:init'>init</a><br>
<li><a href='#Lobby:invite'>invite</a><br>
<li><a href='#Lobby:join'>join</a><br>
<li><a href='#Lobby:leave'>leave</a><br>
<li><a href='#Lobby:onCreate'>onCreate</a><br>
<li><a href='#Lobby:onJoin'>onJoin</a><br>
<li><a href='#Lobby:requestData'>requestData</a><br>
<li><a href='#Lobby:sendChatMessage'>sendChatMessage</a><br>
<li><a href='#Lobby:setData'>setData</a><br>
<li><a href='#Lobby:setJoinable'>setJoinable</a><br>
<li><a href='#Lobby:setLimit'>setLimit</a><br>
<li><a href='#Lobby:setOwner'>setOwner</a><br>
<li><a href='#Lobby:setType'>setType</a><br>
</ul>
<h3><a href='#Socket'>Socket</a></h3>
<ul>
<li><a href='#Socket:destroy'>destroy</a><br>
<li><a href='#Socket:getAddress'>getAddress</a><br>
<li><a href='#Socket:getId'>getId</a><br>
<li><a href='#Socket:getPeer'>getPeer</a><br>
<li><a href='#Socket:init'>init</a><br>
<li><a href='#Socket:isConnected'>isConnected</a><br>
<li><a href='#Socket:receive'>receive</a><br>
<li><a href='#Socket:send'>send</a><br>
<li><a href='#Socket:setPeer'>setPeer</a><br>
<li><a href='#Socket:setProtocol'>setProtocol</a><br>
</ul>
<h3><a href='#UGC'>UGC</a></h3>
<ul>
<li><a href='#UGC:create'>create</a><br>
<li><a href='#UGC:delete'>delete</a><br>
<li><a href='#UGC:download'>download</a><br>
<li><a href='#UGC:fetch'>fetch</a><br>
<li><a href='#UGC:getDetails'>getDetails</a><br>
<li><a href='#UGC:getDownloadInfo'>getDownloadInfo</a><br>
<li><a href='#UGC:getInstallInfo'>getInstallInfo</a><br>
<li><a href='#UGC:init'>init</a><br>
<li><a href='#UGC:isInstalled'>isInstalled</a><br>
<li><a href='#UGC:onCreate'>onCreate</a><br>
<li><a href='#UGC:onDelete'>onDelete</a><br>
<li><a href='#UGC:onFetch'>onFetch</a><br>
<li><a href='#UGC:onStartTracking'>onStartTracking</a><br>
<li><a href='#UGC:onStopTracking'>onStopTracking</a><br>
<li><a href='#UGC:onSubscribe'>onSubscribe</a><br>
<li><a href='#UGC:onUpdate'>onUpdate</a><br>
<li><a href='#UGC:startTracking'>startTracking</a><br>
<li><a href='#UGC:stopTracking'>stopTracking</a><br>
<li><a href='#UGC:subscribe'>subscribe</a><br>
<li><a href='#UGC:update'>update</a><br>
</ul>
<h3><a href='#User'>User</a></h3>
<ul>
<li><a href='#User:activateOverlay'>activateOverlay</a><br>
<li><a href='#User:cancelAuthTicket'>cancelAuthTicket</a><br>
<li><a href='#User:clearAchievement'>clearAchievement</a><br>
<li><a href='#User:clearRichPresence'>clearRichPresence</a><br>
<li><a href='#User:getAchievement'>getAchievement</a><br>
<li><a href='#User:getAuthTicket'>getAuthTicket</a><br>
<li><a href='#User:getAvatar'>getAvatar</a><br>
<li><a href='#User:getGamePlayed'>getGamePlayed</a><br>
<li><a href='#User:getLevel'>getLevel</a><br>
<li><a href='#User:getName'>getName</a><br>
<li><a href='#User:getPlayedWith'>getPlayedWith</a><br>
<li><a href='#User:getRichPresence'>getRichPresence</a><br>
<li><a href='#User:getStat'>getStat</a><br>
<li><a href='#User:init'>init</a><br>
<li><a href='#User:inviteToGame'>inviteToGame</a><br>
<li><a href='#User:isFriend'>isFriend</a><br>
<li><a href='#User:isOnline'>isOnline</a><br>
<li><a href='#User:isOwner'>isOwner</a><br>
<li><a href='#User:onReceiveStats'>onReceiveStats</a><br>
<li><a href='#User:requestAvatar'>requestAvatar</a><br>
<li><a href='#User:requestCurrentStats'>requestCurrentStats</a><br>
<li><a href='#User:requestName'>requestName</a><br>
<li><a href='#User:requestRichPresence'>requestRichPresence</a><br>
<li><a href='#User:requestStats'>requestStats</a><br>
<li><a href='#User:resetStats'>resetStats</a><br>
<li><a href='#User:setAchievement'>setAchievement</a><br>
<li><a href='#User:setName'>setName</a><br>
<li><a href='#User:setPlayedWith'>setPlayedWith</a><br>
<li><a href='#User:setRichPresence'>setRichPresence</a><br>
<li><a href='#User:setStat'>setStat</a><br>
<li><a href='#User:storeStats'>storeStats</a><br>
</ul>
</div>
</div>
</html>